// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseCmd.proto

#ifndef PROTOBUF_INCLUDED_BaseCmd_2eproto
#define PROTOBUF_INCLUDED_BaseCmd_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_BaseCmd_2eproto 

namespace protobuf_BaseCmd_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_BaseCmd_2eproto
namespace DDRCommProto {
class CommonHeader;
class CommonHeaderDefaultTypeInternal;
extern CommonHeaderDefaultTypeInternal _CommonHeader_default_instance_;
class bcLSAddr;
class bcLSAddrDefaultTypeInternal;
extern bcLSAddrDefaultTypeInternal _bcLSAddr_default_instance_;
class bcLSAddr_ServerInfo;
class bcLSAddr_ServerInfoDefaultTypeInternal;
extern bcLSAddr_ServerInfoDefaultTypeInternal _bcLSAddr_ServerInfo_default_instance_;
class heartBeat;
class heartBeatDefaultTypeInternal;
extern heartBeatDefaultTypeInternal _heartBeat_default_instance_;
class notifyAVStream;
class notifyAVStreamDefaultTypeInternal;
extern notifyAVStreamDefaultTypeInternal _notifyAVStream_default_instance_;
class notifyAVStream_fullChannelInfo;
class notifyAVStream_fullChannelInfoDefaultTypeInternal;
extern notifyAVStream_fullChannelInfoDefaultTypeInternal _notifyAVStream_fullChannelInfo_default_instance_;
class notifySerAccess;
class notifySerAccessDefaultTypeInternal;
extern notifySerAccessDefaultTypeInternal _notifySerAccess_default_instance_;
class notifyTerminalAccess;
class notifyTerminalAccessDefaultTypeInternal;
extern notifyTerminalAccessDefaultTypeInternal _notifyTerminalAccess_default_instance_;
class reqAlarm;
class reqAlarmDefaultTypeInternal;
extern reqAlarmDefaultTypeInternal _reqAlarm_default_instance_;
class reqCmd;
class reqCmdDefaultTypeInternal;
extern reqCmdDefaultTypeInternal _reqCmd_default_instance_;
class reqFile;
class reqFileDefaultTypeInternal;
extern reqFileDefaultTypeInternal _reqFile_default_instance_;
class reqFileAddr;
class reqFileAddrDefaultTypeInternal;
extern reqFileAddrDefaultTypeInternal _reqFileAddr_default_instance_;
class reqLogin;
class reqLoginDefaultTypeInternal;
extern reqLoginDefaultTypeInternal _reqLogin_default_instance_;
class reqLogin_msgAVStreamReq;
class reqLogin_msgAVStreamReqDefaultTypeInternal;
extern reqLogin_msgAVStreamReqDefaultTypeInternal _reqLogin_msgAVStreamReq_default_instance_;
class reqStatus;
class reqStatusDefaultTypeInternal;
extern reqStatusDefaultTypeInternal _reqStatus_default_instance_;
class reqTalk;
class reqTalkDefaultTypeInternal;
extern reqTalkDefaultTypeInternal _reqTalk_default_instance_;
class reqTalkHB;
class reqTalkHBDefaultTypeInternal;
extern reqTalkHBDefaultTypeInternal _reqTalkHB_default_instance_;
class reqTextChat;
class reqTextChatDefaultTypeInternal;
extern reqTextChatDefaultTypeInternal _reqTextChat_default_instance_;
class respCmd;
class respCmdDefaultTypeInternal;
extern respCmdDefaultTypeInternal _respCmd_default_instance_;
class respFile;
class respFileDefaultTypeInternal;
extern respFileDefaultTypeInternal _respFile_default_instance_;
class respFileAddr;
class respFileAddrDefaultTypeInternal;
extern respFileAddrDefaultTypeInternal _respFileAddr_default_instance_;
class respLogin;
class respLoginDefaultTypeInternal;
extern respLoginDefaultTypeInternal _respLogin_default_instance_;
class respTalk;
class respTalkDefaultTypeInternal;
extern respTalkDefaultTypeInternal _respTalk_default_instance_;
}  // namespace DDRCommProto
namespace google {
namespace protobuf {
template<> ::DDRCommProto::CommonHeader* Arena::CreateMaybeMessage<::DDRCommProto::CommonHeader>(Arena*);
template<> ::DDRCommProto::bcLSAddr* Arena::CreateMaybeMessage<::DDRCommProto::bcLSAddr>(Arena*);
template<> ::DDRCommProto::bcLSAddr_ServerInfo* Arena::CreateMaybeMessage<::DDRCommProto::bcLSAddr_ServerInfo>(Arena*);
template<> ::DDRCommProto::heartBeat* Arena::CreateMaybeMessage<::DDRCommProto::heartBeat>(Arena*);
template<> ::DDRCommProto::notifyAVStream* Arena::CreateMaybeMessage<::DDRCommProto::notifyAVStream>(Arena*);
template<> ::DDRCommProto::notifyAVStream_fullChannelInfo* Arena::CreateMaybeMessage<::DDRCommProto::notifyAVStream_fullChannelInfo>(Arena*);
template<> ::DDRCommProto::notifySerAccess* Arena::CreateMaybeMessage<::DDRCommProto::notifySerAccess>(Arena*);
template<> ::DDRCommProto::notifyTerminalAccess* Arena::CreateMaybeMessage<::DDRCommProto::notifyTerminalAccess>(Arena*);
template<> ::DDRCommProto::reqAlarm* Arena::CreateMaybeMessage<::DDRCommProto::reqAlarm>(Arena*);
template<> ::DDRCommProto::reqCmd* Arena::CreateMaybeMessage<::DDRCommProto::reqCmd>(Arena*);
template<> ::DDRCommProto::reqFile* Arena::CreateMaybeMessage<::DDRCommProto::reqFile>(Arena*);
template<> ::DDRCommProto::reqFileAddr* Arena::CreateMaybeMessage<::DDRCommProto::reqFileAddr>(Arena*);
template<> ::DDRCommProto::reqLogin* Arena::CreateMaybeMessage<::DDRCommProto::reqLogin>(Arena*);
template<> ::DDRCommProto::reqLogin_msgAVStreamReq* Arena::CreateMaybeMessage<::DDRCommProto::reqLogin_msgAVStreamReq>(Arena*);
template<> ::DDRCommProto::reqStatus* Arena::CreateMaybeMessage<::DDRCommProto::reqStatus>(Arena*);
template<> ::DDRCommProto::reqTalk* Arena::CreateMaybeMessage<::DDRCommProto::reqTalk>(Arena*);
template<> ::DDRCommProto::reqTalkHB* Arena::CreateMaybeMessage<::DDRCommProto::reqTalkHB>(Arena*);
template<> ::DDRCommProto::reqTextChat* Arena::CreateMaybeMessage<::DDRCommProto::reqTextChat>(Arena*);
template<> ::DDRCommProto::respCmd* Arena::CreateMaybeMessage<::DDRCommProto::respCmd>(Arena*);
template<> ::DDRCommProto::respFile* Arena::CreateMaybeMessage<::DDRCommProto::respFile>(Arena*);
template<> ::DDRCommProto::respFileAddr* Arena::CreateMaybeMessage<::DDRCommProto::respFileAddr>(Arena*);
template<> ::DDRCommProto::respLogin* Arena::CreateMaybeMessage<::DDRCommProto::respLogin>(Arena*);
template<> ::DDRCommProto::respTalk* Arena::CreateMaybeMessage<::DDRCommProto::respTalk>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace DDRCommProto {

enum CommonHeader_eFlowDir {
  CommonHeader_eFlowDir_UNKNOWN2RS = 0,
  CommonHeader_eFlowDir_RS2M = 1,
  CommonHeader_eFlowDir_M2RS = 2,
  CommonHeader_eFlowDir_RS2RR = 3,
  CommonHeader_eFlowDir_RR2RS = 4,
  CommonHeader_eFlowDir_UNKNOWN2LS = 5,
  CommonHeader_eFlowDir_LS2C = 6,
  CommonHeader_eFlowDir_C2LS = 7,
  CommonHeader_eFlowDir_LS2LSM = 8,
  CommonHeader_eFlowDir_LSM2LS = 9,
  CommonHeader_eFlowDir_CommonHeader_eFlowDir_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommonHeader_eFlowDir_CommonHeader_eFlowDir_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommonHeader_eFlowDir_IsValid(int value);
const CommonHeader_eFlowDir CommonHeader_eFlowDir_eFlowDir_MIN = CommonHeader_eFlowDir_UNKNOWN2RS;
const CommonHeader_eFlowDir CommonHeader_eFlowDir_eFlowDir_MAX = CommonHeader_eFlowDir_LSM2LS;
const int CommonHeader_eFlowDir_eFlowDir_ARRAYSIZE = CommonHeader_eFlowDir_eFlowDir_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonHeader_eFlowDir_descriptor();
inline const ::std::string& CommonHeader_eFlowDir_Name(CommonHeader_eFlowDir value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonHeader_eFlowDir_descriptor(), value);
}
inline bool CommonHeader_eFlowDir_Parse(
    const ::std::string& name, CommonHeader_eFlowDir* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonHeader_eFlowDir>(
    CommonHeader_eFlowDir_descriptor(), name, value);
}
enum CommonHeader_eSrcCondition {
  CommonHeader_eSrcCondition_NoCond = 0,
  CommonHeader_eSrcCondition_Op = 1,
  CommonHeader_eSrcCondition_CommonHeader_eSrcCondition_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommonHeader_eSrcCondition_CommonHeader_eSrcCondition_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommonHeader_eSrcCondition_IsValid(int value);
const CommonHeader_eSrcCondition CommonHeader_eSrcCondition_eSrcCondition_MIN = CommonHeader_eSrcCondition_NoCond;
const CommonHeader_eSrcCondition CommonHeader_eSrcCondition_eSrcCondition_MAX = CommonHeader_eSrcCondition_Op;
const int CommonHeader_eSrcCondition_eSrcCondition_ARRAYSIZE = CommonHeader_eSrcCondition_eSrcCondition_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonHeader_eSrcCondition_descriptor();
inline const ::std::string& CommonHeader_eSrcCondition_Name(CommonHeader_eSrcCondition value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonHeader_eSrcCondition_descriptor(), value);
}
inline bool CommonHeader_eSrcCondition_Parse(
    const ::std::string& name, CommonHeader_eSrcCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonHeader_eSrcCondition>(
    CommonHeader_eSrcCondition_descriptor(), name, value);
}
enum CommonHeader_eForwardingType {
  CommonHeader_eForwardingType_NoForwarding = 0,
  CommonHeader_eForwardingType_LSMAll = 1,
  CommonHeader_eForwardingType_CltMonAll = 2,
  CommonHeader_eForwardingType_ToOp = 3,
  CommonHeader_eForwardingType_RoutingBack = 4,
  CommonHeader_eForwardingType_CommonHeader_eForwardingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommonHeader_eForwardingType_CommonHeader_eForwardingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommonHeader_eForwardingType_IsValid(int value);
const CommonHeader_eForwardingType CommonHeader_eForwardingType_eForwardingType_MIN = CommonHeader_eForwardingType_NoForwarding;
const CommonHeader_eForwardingType CommonHeader_eForwardingType_eForwardingType_MAX = CommonHeader_eForwardingType_RoutingBack;
const int CommonHeader_eForwardingType_eForwardingType_ARRAYSIZE = CommonHeader_eForwardingType_eForwardingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonHeader_eForwardingType_descriptor();
inline const ::std::string& CommonHeader_eForwardingType_Name(CommonHeader_eForwardingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonHeader_eForwardingType_descriptor(), value);
}
inline bool CommonHeader_eForwardingType_Parse(
    const ::std::string& name, CommonHeader_eForwardingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonHeader_eForwardingType>(
    CommonHeader_eForwardingType_descriptor(), name, value);
}
enum CommonHeader_eSrcRecType {
  CommonHeader_eSrcRecType_NoRec = 0,
  CommonHeader_eSrcRecType_RecSrc = 1,
  CommonHeader_eSrcRecType_CommonHeader_eSrcRecType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommonHeader_eSrcRecType_CommonHeader_eSrcRecType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommonHeader_eSrcRecType_IsValid(int value);
const CommonHeader_eSrcRecType CommonHeader_eSrcRecType_eSrcRecType_MIN = CommonHeader_eSrcRecType_NoRec;
const CommonHeader_eSrcRecType CommonHeader_eSrcRecType_eSrcRecType_MAX = CommonHeader_eSrcRecType_RecSrc;
const int CommonHeader_eSrcRecType_eSrcRecType_ARRAYSIZE = CommonHeader_eSrcRecType_eSrcRecType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonHeader_eSrcRecType_descriptor();
inline const ::std::string& CommonHeader_eSrcRecType_Name(CommonHeader_eSrcRecType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonHeader_eSrcRecType_descriptor(), value);
}
inline bool CommonHeader_eSrcRecType_Parse(
    const ::std::string& name, CommonHeader_eSrcRecType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonHeader_eSrcRecType>(
    CommonHeader_eSrcRecType_descriptor(), name, value);
}
enum reqLogin_eCltType {
  reqLogin_eCltType_client = 0,
  reqLogin_eCltType_androidClient = 1,
  reqLogin_eCltType_LSM = 2,
  reqLogin_eCltType_reqLogin_eCltType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqLogin_eCltType_reqLogin_eCltType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqLogin_eCltType_IsValid(int value);
const reqLogin_eCltType reqLogin_eCltType_eCltType_MIN = reqLogin_eCltType_client;
const reqLogin_eCltType reqLogin_eCltType_eCltType_MAX = reqLogin_eCltType_LSM;
const int reqLogin_eCltType_eCltType_ARRAYSIZE = reqLogin_eCltType_eCltType_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqLogin_eCltType_descriptor();
inline const ::std::string& reqLogin_eCltType_Name(reqLogin_eCltType value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqLogin_eCltType_descriptor(), value);
}
inline bool reqLogin_eCltType_Parse(
    const ::std::string& name, reqLogin_eCltType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqLogin_eCltType>(
    reqLogin_eCltType_descriptor(), name, value);
}
enum respLogin_eLoginRetCode {
  respLogin_eLoginRetCode_success = 0,
  respLogin_eLoginRetCode_server_busy = 1,
  respLogin_eLoginRetCode_server_limit_reached = 2,
  respLogin_eLoginRetCode_UID_error = 3,
  respLogin_eLoginRetCode_incorrect_password = 4,
  respLogin_eLoginRetCode_respLogin_eLoginRetCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respLogin_eLoginRetCode_respLogin_eLoginRetCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respLogin_eLoginRetCode_IsValid(int value);
const respLogin_eLoginRetCode respLogin_eLoginRetCode_eLoginRetCode_MIN = respLogin_eLoginRetCode_success;
const respLogin_eLoginRetCode respLogin_eLoginRetCode_eLoginRetCode_MAX = respLogin_eLoginRetCode_incorrect_password;
const int respLogin_eLoginRetCode_eLoginRetCode_ARRAYSIZE = respLogin_eLoginRetCode_eLoginRetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* respLogin_eLoginRetCode_descriptor();
inline const ::std::string& respLogin_eLoginRetCode_Name(respLogin_eLoginRetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    respLogin_eLoginRetCode_descriptor(), value);
}
inline bool respLogin_eLoginRetCode_Parse(
    const ::std::string& name, respLogin_eLoginRetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respLogin_eLoginRetCode>(
    respLogin_eLoginRetCode_descriptor(), name, value);
}
enum respLogin_eCltType {
  respLogin_eCltType_client = 0,
  respLogin_eCltType_androidClient = 1,
  respLogin_eCltType_LSM = 2,
  respLogin_eCltType_respLogin_eCltType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respLogin_eCltType_respLogin_eCltType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respLogin_eCltType_IsValid(int value);
const respLogin_eCltType respLogin_eCltType_eCltType_MIN = respLogin_eCltType_client;
const respLogin_eCltType respLogin_eCltType_eCltType_MAX = respLogin_eCltType_LSM;
const int respLogin_eCltType_eCltType_ARRAYSIZE = respLogin_eCltType_eCltType_MAX + 1;

const ::google::protobuf::EnumDescriptor* respLogin_eCltType_descriptor();
inline const ::std::string& respLogin_eCltType_Name(respLogin_eCltType value) {
  return ::google::protobuf::internal::NameOfEnum(
    respLogin_eCltType_descriptor(), value);
}
inline bool respLogin_eCltType_Parse(
    const ::std::string& name, respLogin_eCltType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respLogin_eCltType>(
    respLogin_eCltType_descriptor(), name, value);
}
enum reqTalk_eCallerType {
  reqTalk_eCallerType_client = 0,
  reqTalk_eCallerType_monitor = 1,
  reqTalk_eCallerType_robot_LSM = 2,
  reqTalk_eCallerType_reqTalk_eCallerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqTalk_eCallerType_reqTalk_eCallerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqTalk_eCallerType_IsValid(int value);
const reqTalk_eCallerType reqTalk_eCallerType_eCallerType_MIN = reqTalk_eCallerType_client;
const reqTalk_eCallerType reqTalk_eCallerType_eCallerType_MAX = reqTalk_eCallerType_robot_LSM;
const int reqTalk_eCallerType_eCallerType_ARRAYSIZE = reqTalk_eCallerType_eCallerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqTalk_eCallerType_descriptor();
inline const ::std::string& reqTalk_eCallerType_Name(reqTalk_eCallerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqTalk_eCallerType_descriptor(), value);
}
inline bool reqTalk_eCallerType_Parse(
    const ::std::string& name, reqTalk_eCallerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqTalk_eCallerType>(
    reqTalk_eCallerType_descriptor(), name, value);
}
enum respTalk_eReceiverType {
  respTalk_eReceiverType_client = 0,
  respTalk_eReceiverType_monitor = 1,
  respTalk_eReceiverType_robot_LSM = 2,
  respTalk_eReceiverType_respTalk_eReceiverType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respTalk_eReceiverType_respTalk_eReceiverType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respTalk_eReceiverType_IsValid(int value);
const respTalk_eReceiverType respTalk_eReceiverType_eReceiverType_MIN = respTalk_eReceiverType_client;
const respTalk_eReceiverType respTalk_eReceiverType_eReceiverType_MAX = respTalk_eReceiverType_robot_LSM;
const int respTalk_eReceiverType_eReceiverType_ARRAYSIZE = respTalk_eReceiverType_eReceiverType_MAX + 1;

const ::google::protobuf::EnumDescriptor* respTalk_eReceiverType_descriptor();
inline const ::std::string& respTalk_eReceiverType_Name(respTalk_eReceiverType value) {
  return ::google::protobuf::internal::NameOfEnum(
    respTalk_eReceiverType_descriptor(), value);
}
inline bool respTalk_eReceiverType_Parse(
    const ::std::string& name, respTalk_eReceiverType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respTalk_eReceiverType>(
    respTalk_eReceiverType_descriptor(), name, value);
}
enum reqFile_eFileTypes {
  reqFile_eFileTypes_FileContents = 0,
  reqFile_eFileTypes_FileList = 1,
  reqFile_eFileTypes_FolderFlist = 2,
  reqFile_eFileTypes_reqFile_eFileTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqFile_eFileTypes_reqFile_eFileTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqFile_eFileTypes_IsValid(int value);
const reqFile_eFileTypes reqFile_eFileTypes_eFileTypes_MIN = reqFile_eFileTypes_FileContents;
const reqFile_eFileTypes reqFile_eFileTypes_eFileTypes_MAX = reqFile_eFileTypes_FolderFlist;
const int reqFile_eFileTypes_eFileTypes_ARRAYSIZE = reqFile_eFileTypes_eFileTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqFile_eFileTypes_descriptor();
inline const ::std::string& reqFile_eFileTypes_Name(reqFile_eFileTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqFile_eFileTypes_descriptor(), value);
}
inline bool reqFile_eFileTypes_Parse(
    const ::std::string& name, reqFile_eFileTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqFile_eFileTypes>(
    reqFile_eFileTypes_descriptor(), name, value);
}
enum respFile_eFileTypes {
  respFile_eFileTypes_FileContents = 0,
  respFile_eFileTypes_FileList = 1,
  respFile_eFileTypes_FolderFlist = 2,
  respFile_eFileTypes_respFile_eFileTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respFile_eFileTypes_respFile_eFileTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respFile_eFileTypes_IsValid(int value);
const respFile_eFileTypes respFile_eFileTypes_eFileTypes_MIN = respFile_eFileTypes_FileContents;
const respFile_eFileTypes respFile_eFileTypes_eFileTypes_MAX = respFile_eFileTypes_FolderFlist;
const int respFile_eFileTypes_eFileTypes_ARRAYSIZE = respFile_eFileTypes_eFileTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* respFile_eFileTypes_descriptor();
inline const ::std::string& respFile_eFileTypes_Name(respFile_eFileTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    respFile_eFileTypes_descriptor(), value);
}
inline bool respFile_eFileTypes_Parse(
    const ::std::string& name, respFile_eFileTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respFile_eFileTypes>(
    respFile_eFileTypes_descriptor(), name, value);
}
enum reqFileAddr_eFileTypes {
  reqFileAddr_eFileTypes_FileContents = 0,
  reqFileAddr_eFileTypes_FileList = 1,
  reqFileAddr_eFileTypes_FolderFlist = 2,
  reqFileAddr_eFileTypes_reqFileAddr_eFileTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqFileAddr_eFileTypes_reqFileAddr_eFileTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqFileAddr_eFileTypes_IsValid(int value);
const reqFileAddr_eFileTypes reqFileAddr_eFileTypes_eFileTypes_MIN = reqFileAddr_eFileTypes_FileContents;
const reqFileAddr_eFileTypes reqFileAddr_eFileTypes_eFileTypes_MAX = reqFileAddr_eFileTypes_FolderFlist;
const int reqFileAddr_eFileTypes_eFileTypes_ARRAYSIZE = reqFileAddr_eFileTypes_eFileTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqFileAddr_eFileTypes_descriptor();
inline const ::std::string& reqFileAddr_eFileTypes_Name(reqFileAddr_eFileTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqFileAddr_eFileTypes_descriptor(), value);
}
inline bool reqFileAddr_eFileTypes_Parse(
    const ::std::string& name, reqFileAddr_eFileTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqFileAddr_eFileTypes>(
    reqFileAddr_eFileTypes_descriptor(), name, value);
}
enum respFileAddr_eFileTypes {
  respFileAddr_eFileTypes_FileContents = 0,
  respFileAddr_eFileTypes_FileList = 1,
  respFileAddr_eFileTypes_FolderFlist = 2,
  respFileAddr_eFileTypes_respFileAddr_eFileTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respFileAddr_eFileTypes_respFileAddr_eFileTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respFileAddr_eFileTypes_IsValid(int value);
const respFileAddr_eFileTypes respFileAddr_eFileTypes_eFileTypes_MIN = respFileAddr_eFileTypes_FileContents;
const respFileAddr_eFileTypes respFileAddr_eFileTypes_eFileTypes_MAX = respFileAddr_eFileTypes_FolderFlist;
const int respFileAddr_eFileTypes_eFileTypes_ARRAYSIZE = respFileAddr_eFileTypes_eFileTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* respFileAddr_eFileTypes_descriptor();
inline const ::std::string& respFileAddr_eFileTypes_Name(respFileAddr_eFileTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    respFileAddr_eFileTypes_descriptor(), value);
}
inline bool respFileAddr_eFileTypes_Parse(
    const ::std::string& name, respFileAddr_eFileTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respFileAddr_eFileTypes>(
    respFileAddr_eFileTypes_descriptor(), name, value);
}
// ===================================================================

class CommonHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.CommonHeader) */ {
 public:
  CommonHeader();
  virtual ~CommonHeader();

  CommonHeader(const CommonHeader& from);

  inline CommonHeader& operator=(const CommonHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommonHeader(CommonHeader&& from) noexcept
    : CommonHeader() {
    *this = ::std::move(from);
  }

  inline CommonHeader& operator=(CommonHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonHeader* internal_default_instance() {
    return reinterpret_cast<const CommonHeader*>(
               &_CommonHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CommonHeader* other);
  friend void swap(CommonHeader& a, CommonHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonHeader* New() const final {
    return CreateMaybeMessage<CommonHeader>(NULL);
  }

  CommonHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommonHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommonHeader& from);
  void MergeFrom(const CommonHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CommonHeader_eFlowDir eFlowDir;
  static const eFlowDir UNKNOWN2RS =
    CommonHeader_eFlowDir_UNKNOWN2RS;
  static const eFlowDir RS2M =
    CommonHeader_eFlowDir_RS2M;
  static const eFlowDir M2RS =
    CommonHeader_eFlowDir_M2RS;
  static const eFlowDir RS2RR =
    CommonHeader_eFlowDir_RS2RR;
  static const eFlowDir RR2RS =
    CommonHeader_eFlowDir_RR2RS;
  static const eFlowDir UNKNOWN2LS =
    CommonHeader_eFlowDir_UNKNOWN2LS;
  static const eFlowDir LS2C =
    CommonHeader_eFlowDir_LS2C;
  static const eFlowDir C2LS =
    CommonHeader_eFlowDir_C2LS;
  static const eFlowDir LS2LSM =
    CommonHeader_eFlowDir_LS2LSM;
  static const eFlowDir LSM2LS =
    CommonHeader_eFlowDir_LSM2LS;
  static inline bool eFlowDir_IsValid(int value) {
    return CommonHeader_eFlowDir_IsValid(value);
  }
  static const eFlowDir eFlowDir_MIN =
    CommonHeader_eFlowDir_eFlowDir_MIN;
  static const eFlowDir eFlowDir_MAX =
    CommonHeader_eFlowDir_eFlowDir_MAX;
  static const int eFlowDir_ARRAYSIZE =
    CommonHeader_eFlowDir_eFlowDir_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFlowDir_descriptor() {
    return CommonHeader_eFlowDir_descriptor();
  }
  static inline const ::std::string& eFlowDir_Name(eFlowDir value) {
    return CommonHeader_eFlowDir_Name(value);
  }
  static inline bool eFlowDir_Parse(const ::std::string& name,
      eFlowDir* value) {
    return CommonHeader_eFlowDir_Parse(name, value);
  }

  typedef CommonHeader_eSrcCondition eSrcCondition;
  static const eSrcCondition NoCond =
    CommonHeader_eSrcCondition_NoCond;
  static const eSrcCondition Op =
    CommonHeader_eSrcCondition_Op;
  static inline bool eSrcCondition_IsValid(int value) {
    return CommonHeader_eSrcCondition_IsValid(value);
  }
  static const eSrcCondition eSrcCondition_MIN =
    CommonHeader_eSrcCondition_eSrcCondition_MIN;
  static const eSrcCondition eSrcCondition_MAX =
    CommonHeader_eSrcCondition_eSrcCondition_MAX;
  static const int eSrcCondition_ARRAYSIZE =
    CommonHeader_eSrcCondition_eSrcCondition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eSrcCondition_descriptor() {
    return CommonHeader_eSrcCondition_descriptor();
  }
  static inline const ::std::string& eSrcCondition_Name(eSrcCondition value) {
    return CommonHeader_eSrcCondition_Name(value);
  }
  static inline bool eSrcCondition_Parse(const ::std::string& name,
      eSrcCondition* value) {
    return CommonHeader_eSrcCondition_Parse(name, value);
  }

  typedef CommonHeader_eForwardingType eForwardingType;
  static const eForwardingType NoForwarding =
    CommonHeader_eForwardingType_NoForwarding;
  static const eForwardingType LSMAll =
    CommonHeader_eForwardingType_LSMAll;
  static const eForwardingType CltMonAll =
    CommonHeader_eForwardingType_CltMonAll;
  static const eForwardingType ToOp =
    CommonHeader_eForwardingType_ToOp;
  static const eForwardingType RoutingBack =
    CommonHeader_eForwardingType_RoutingBack;
  static inline bool eForwardingType_IsValid(int value) {
    return CommonHeader_eForwardingType_IsValid(value);
  }
  static const eForwardingType eForwardingType_MIN =
    CommonHeader_eForwardingType_eForwardingType_MIN;
  static const eForwardingType eForwardingType_MAX =
    CommonHeader_eForwardingType_eForwardingType_MAX;
  static const int eForwardingType_ARRAYSIZE =
    CommonHeader_eForwardingType_eForwardingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eForwardingType_descriptor() {
    return CommonHeader_eForwardingType_descriptor();
  }
  static inline const ::std::string& eForwardingType_Name(eForwardingType value) {
    return CommonHeader_eForwardingType_Name(value);
  }
  static inline bool eForwardingType_Parse(const ::std::string& name,
      eForwardingType* value) {
    return CommonHeader_eForwardingType_Parse(name, value);
  }

  typedef CommonHeader_eSrcRecType eSrcRecType;
  static const eSrcRecType NoRec =
    CommonHeader_eSrcRecType_NoRec;
  static const eSrcRecType RecSrc =
    CommonHeader_eSrcRecType_RecSrc;
  static inline bool eSrcRecType_IsValid(int value) {
    return CommonHeader_eSrcRecType_IsValid(value);
  }
  static const eSrcRecType eSrcRecType_MIN =
    CommonHeader_eSrcRecType_eSrcRecType_MIN;
  static const eSrcRecType eSrcRecType_MAX =
    CommonHeader_eSrcRecType_eSrcRecType_MAX;
  static const int eSrcRecType_ARRAYSIZE =
    CommonHeader_eSrcRecType_eSrcRecType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eSrcRecType_descriptor() {
    return CommonHeader_eSrcRecType_descriptor();
  }
  static inline const ::std::string& eSrcRecType_Name(eSrcRecType value) {
    return CommonHeader_eSrcRecType_Name(value);
  }
  static inline bool eSrcRecType_Parse(const ::std::string& name,
      eSrcRecType* value) {
    return CommonHeader_eSrcRecType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DDRCommProto.CommonHeader.eFlowDir flowDirection = 2;
  int flowdirection_size() const;
  void clear_flowdirection();
  static const int kFlowDirectionFieldNumber = 2;
  ::DDRCommProto::CommonHeader_eFlowDir flowdirection(int index) const;
  void set_flowdirection(int index, ::DDRCommProto::CommonHeader_eFlowDir value);
  void add_flowdirection(::DDRCommProto::CommonHeader_eFlowDir value);
  const ::google::protobuf::RepeatedField<int>& flowdirection() const;
  ::google::protobuf::RepeatedField<int>* mutable_flowdirection();

  // repeated string prevRouteAddr = 7;
  int prevrouteaddr_size() const;
  void clear_prevrouteaddr();
  static const int kPrevRouteAddrFieldNumber = 7;
  const ::std::string& prevrouteaddr(int index) const;
  ::std::string* mutable_prevrouteaddr(int index);
  void set_prevrouteaddr(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_prevrouteaddr(int index, ::std::string&& value);
  #endif
  void set_prevrouteaddr(int index, const char* value);
  void set_prevrouteaddr(int index, const char* value, size_t size);
  ::std::string* add_prevrouteaddr();
  void add_prevrouteaddr(const ::std::string& value);
  #if LANG_CXX11
  void add_prevrouteaddr(::std::string&& value);
  #endif
  void add_prevrouteaddr(const char* value);
  void add_prevrouteaddr(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& prevrouteaddr() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_prevrouteaddr();

  // string bodyType = 1;
  void clear_bodytype();
  static const int kBodyTypeFieldNumber = 1;
  const ::std::string& bodytype() const;
  void set_bodytype(const ::std::string& value);
  #if LANG_CXX11
  void set_bodytype(::std::string&& value);
  #endif
  void set_bodytype(const char* value);
  void set_bodytype(const char* value, size_t size);
  ::std::string* mutable_bodytype();
  ::std::string* release_bodytype();
  void set_allocated_bodytype(::std::string* bodytype);

  // int32 bOriginal = 3;
  void clear_boriginal();
  static const int kBOriginalFieldNumber = 3;
  ::google::protobuf::int32 boriginal() const;
  void set_boriginal(::google::protobuf::int32 value);

  // .DDRCommProto.CommonHeader.eSrcCondition srcCond = 4;
  void clear_srccond();
  static const int kSrcCondFieldNumber = 4;
  ::DDRCommProto::CommonHeader_eSrcCondition srccond() const;
  void set_srccond(::DDRCommProto::CommonHeader_eSrcCondition value);

  // .DDRCommProto.CommonHeader.eForwardingType forwardType = 5;
  void clear_forwardtype();
  static const int kForwardTypeFieldNumber = 5;
  ::DDRCommProto::CommonHeader_eForwardingType forwardtype() const;
  void set_forwardtype(::DDRCommProto::CommonHeader_eForwardingType value);

  // .DDRCommProto.CommonHeader.eSrcRecType recType = 6;
  void clear_rectype();
  static const int kRecTypeFieldNumber = 6;
  ::DDRCommProto::CommonHeader_eSrcRecType rectype() const;
  void set_rectype(::DDRCommProto::CommonHeader_eSrcRecType value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.CommonHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> flowdirection_;
  mutable int _flowdirection_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> prevrouteaddr_;
  ::google::protobuf::internal::ArenaStringPtr bodytype_;
  ::google::protobuf::int32 boriginal_;
  int srccond_;
  int forwardtype_;
  int rectype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class heartBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.heartBeat) */ {
 public:
  heartBeat();
  virtual ~heartBeat();

  heartBeat(const heartBeat& from);

  inline heartBeat& operator=(const heartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  heartBeat(heartBeat&& from) noexcept
    : heartBeat() {
    *this = ::std::move(from);
  }

  inline heartBeat& operator=(heartBeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const heartBeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const heartBeat* internal_default_instance() {
    return reinterpret_cast<const heartBeat*>(
               &_heartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(heartBeat* other);
  friend void swap(heartBeat& a, heartBeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline heartBeat* New() const final {
    return CreateMaybeMessage<heartBeat>(NULL);
  }

  heartBeat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<heartBeat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const heartBeat& from);
  void MergeFrom(const heartBeat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(heartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string whatever = 1;
  void clear_whatever();
  static const int kWhateverFieldNumber = 1;
  const ::std::string& whatever() const;
  void set_whatever(const ::std::string& value);
  #if LANG_CXX11
  void set_whatever(::std::string&& value);
  #endif
  void set_whatever(const char* value);
  void set_whatever(const char* value, size_t size);
  ::std::string* mutable_whatever();
  ::std::string* release_whatever();
  void set_allocated_whatever(::std::string* whatever);

  // @@protoc_insertion_point(class_scope:DDRCommProto.heartBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr whatever_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bcLSAddr_ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.bcLSAddr.ServerInfo) */ {
 public:
  bcLSAddr_ServerInfo();
  virtual ~bcLSAddr_ServerInfo();

  bcLSAddr_ServerInfo(const bcLSAddr_ServerInfo& from);

  inline bcLSAddr_ServerInfo& operator=(const bcLSAddr_ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bcLSAddr_ServerInfo(bcLSAddr_ServerInfo&& from) noexcept
    : bcLSAddr_ServerInfo() {
    *this = ::std::move(from);
  }

  inline bcLSAddr_ServerInfo& operator=(bcLSAddr_ServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const bcLSAddr_ServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bcLSAddr_ServerInfo* internal_default_instance() {
    return reinterpret_cast<const bcLSAddr_ServerInfo*>(
               &_bcLSAddr_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(bcLSAddr_ServerInfo* other);
  friend void swap(bcLSAddr_ServerInfo& a, bcLSAddr_ServerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bcLSAddr_ServerInfo* New() const final {
    return CreateMaybeMessage<bcLSAddr_ServerInfo>(NULL);
  }

  bcLSAddr_ServerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bcLSAddr_ServerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bcLSAddr_ServerInfo& from);
  void MergeFrom(const bcLSAddr_ServerInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bcLSAddr_ServerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ips = 2;
  int ips_size() const;
  void clear_ips();
  static const int kIpsFieldNumber = 2;
  const ::std::string& ips(int index) const;
  ::std::string* mutable_ips(int index);
  void set_ips(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ips(int index, ::std::string&& value);
  #endif
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  ::std::string* add_ips();
  void add_ips(const ::std::string& value);
  #if LANG_CXX11
  void add_ips(::std::string&& value);
  #endif
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ips();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.bcLSAddr.ServerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ips_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bcLSAddr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.bcLSAddr) */ {
 public:
  bcLSAddr();
  virtual ~bcLSAddr();

  bcLSAddr(const bcLSAddr& from);

  inline bcLSAddr& operator=(const bcLSAddr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bcLSAddr(bcLSAddr&& from) noexcept
    : bcLSAddr() {
    *this = ::std::move(from);
  }

  inline bcLSAddr& operator=(bcLSAddr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const bcLSAddr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bcLSAddr* internal_default_instance() {
    return reinterpret_cast<const bcLSAddr*>(
               &_bcLSAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(bcLSAddr* other);
  friend void swap(bcLSAddr& a, bcLSAddr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bcLSAddr* New() const final {
    return CreateMaybeMessage<bcLSAddr>(NULL);
  }

  bcLSAddr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bcLSAddr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bcLSAddr& from);
  void MergeFrom(const bcLSAddr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bcLSAddr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef bcLSAddr_ServerInfo ServerInfo;

  // accessors -------------------------------------------------------

  // .DDRCommProto.bcLSAddr.ServerInfo LSInfo = 1;
  bool has_lsinfo() const;
  void clear_lsinfo();
  static const int kLSInfoFieldNumber = 1;
  private:
  const ::DDRCommProto::bcLSAddr_ServerInfo& _internal_lsinfo() const;
  public:
  const ::DDRCommProto::bcLSAddr_ServerInfo& lsinfo() const;
  ::DDRCommProto::bcLSAddr_ServerInfo* release_lsinfo();
  ::DDRCommProto::bcLSAddr_ServerInfo* mutable_lsinfo();
  void set_allocated_lsinfo(::DDRCommProto::bcLSAddr_ServerInfo* lsinfo);

  // @@protoc_insertion_point(class_scope:DDRCommProto.bcLSAddr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::DDRCommProto::bcLSAddr_ServerInfo* lsinfo_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqLogin_msgAVStreamReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqLogin.msgAVStreamReq) */ {
 public:
  reqLogin_msgAVStreamReq();
  virtual ~reqLogin_msgAVStreamReq();

  reqLogin_msgAVStreamReq(const reqLogin_msgAVStreamReq& from);

  inline reqLogin_msgAVStreamReq& operator=(const reqLogin_msgAVStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqLogin_msgAVStreamReq(reqLogin_msgAVStreamReq&& from) noexcept
    : reqLogin_msgAVStreamReq() {
    *this = ::std::move(from);
  }

  inline reqLogin_msgAVStreamReq& operator=(reqLogin_msgAVStreamReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqLogin_msgAVStreamReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqLogin_msgAVStreamReq* internal_default_instance() {
    return reinterpret_cast<const reqLogin_msgAVStreamReq*>(
               &_reqLogin_msgAVStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(reqLogin_msgAVStreamReq* other);
  friend void swap(reqLogin_msgAVStreamReq& a, reqLogin_msgAVStreamReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqLogin_msgAVStreamReq* New() const final {
    return CreateMaybeMessage<reqLogin_msgAVStreamReq>(NULL);
  }

  reqLogin_msgAVStreamReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqLogin_msgAVStreamReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqLogin_msgAVStreamReq& from);
  void MergeFrom(const reqLogin_msgAVStreamReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqLogin_msgAVStreamReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chName = 2;
  void clear_chname();
  static const int kChNameFieldNumber = 2;
  const ::std::string& chname() const;
  void set_chname(const ::std::string& value);
  #if LANG_CXX11
  void set_chname(::std::string&& value);
  #endif
  void set_chname(const char* value);
  void set_chname(const char* value, size_t size);
  ::std::string* mutable_chname();
  ::std::string* release_chname();
  void set_allocated_chname(::std::string* chname);

  // int32 avType = 1;
  void clear_avtype();
  static const int kAvTypeFieldNumber = 1;
  ::google::protobuf::int32 avtype() const;
  void set_avtype(::google::protobuf::int32 value);

  // int32 bandwidthReq = 3;
  void clear_bandwidthreq();
  static const int kBandwidthReqFieldNumber = 3;
  ::google::protobuf::int32 bandwidthreq() const;
  void set_bandwidthreq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqLogin.msgAVStreamReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chname_;
  ::google::protobuf::int32 avtype_;
  ::google::protobuf::int32 bandwidthreq_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqLogin) */ {
 public:
  reqLogin();
  virtual ~reqLogin();

  reqLogin(const reqLogin& from);

  inline reqLogin& operator=(const reqLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqLogin(reqLogin&& from) noexcept
    : reqLogin() {
    *this = ::std::move(from);
  }

  inline reqLogin& operator=(reqLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqLogin* internal_default_instance() {
    return reinterpret_cast<const reqLogin*>(
               &_reqLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(reqLogin* other);
  friend void swap(reqLogin& a, reqLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqLogin* New() const final {
    return CreateMaybeMessage<reqLogin>(NULL);
  }

  reqLogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqLogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqLogin& from);
  void MergeFrom(const reqLogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqLogin_msgAVStreamReq msgAVStreamReq;

  typedef reqLogin_eCltType eCltType;
  static const eCltType client =
    reqLogin_eCltType_client;
  static const eCltType androidClient =
    reqLogin_eCltType_androidClient;
  static const eCltType LSM =
    reqLogin_eCltType_LSM;
  static inline bool eCltType_IsValid(int value) {
    return reqLogin_eCltType_IsValid(value);
  }
  static const eCltType eCltType_MIN =
    reqLogin_eCltType_eCltType_MIN;
  static const eCltType eCltType_MAX =
    reqLogin_eCltType_eCltType_MAX;
  static const int eCltType_ARRAYSIZE =
    reqLogin_eCltType_eCltType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCltType_descriptor() {
    return reqLogin_eCltType_descriptor();
  }
  static inline const ::std::string& eCltType_Name(eCltType value) {
    return reqLogin_eCltType_Name(value);
  }
  static inline bool eCltType_Parse(const ::std::string& name,
      eCltType* value) {
    return reqLogin_eCltType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DDRCommProto.reqLogin.msgAVStreamReq avStreamReq = 7;
  int avstreamreq_size() const;
  void clear_avstreamreq();
  static const int kAvStreamReqFieldNumber = 7;
  ::DDRCommProto::reqLogin_msgAVStreamReq* mutable_avstreamreq(int index);
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >*
      mutable_avstreamreq();
  const ::DDRCommProto::reqLogin_msgAVStreamReq& avstreamreq(int index) const;
  ::DDRCommProto::reqLogin_msgAVStreamReq* add_avstreamreq();
  const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >&
      avstreamreq() const;

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string robotID = 3;
  void clear_robotid();
  static const int kRobotIDFieldNumber = 3;
  const ::std::string& robotid() const;
  void set_robotid(const ::std::string& value);
  #if LANG_CXX11
  void set_robotid(::std::string&& value);
  #endif
  void set_robotid(const char* value);
  void set_robotid(const char* value, size_t size);
  ::std::string* mutable_robotid();
  ::std::string* release_robotid();
  void set_allocated_robotid(::std::string* robotid);

  // string robotPWD = 4;
  void clear_robotpwd();
  static const int kRobotPWDFieldNumber = 4;
  const ::std::string& robotpwd() const;
  void set_robotpwd(const ::std::string& value);
  #if LANG_CXX11
  void set_robotpwd(::std::string&& value);
  #endif
  void set_robotpwd(const char* value);
  void set_robotpwd(const char* value, size_t size);
  ::std::string* mutable_robotpwd();
  ::std::string* release_robotpwd();
  void set_allocated_robotpwd(::std::string* robotpwd);

  // .DDRCommProto.reqLogin.eCltType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::DDRCommProto::reqLogin_eCltType type() const;
  void set_type(::DDRCommProto::reqLogin_eCltType value);

  // int32 cltOpLv = 5;
  void clear_cltoplv();
  static const int kCltOpLvFieldNumber = 5;
  ::google::protobuf::int32 cltoplv() const;
  void set_cltoplv(::google::protobuf::int32 value);

  // int32 UID = 6;
  void clear_uid();
  static const int kUIDFieldNumber = 6;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq > avstreamreq_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr robotid_;
  ::google::protobuf::internal::ArenaStringPtr robotpwd_;
  int type_;
  ::google::protobuf::int32 cltoplv_;
  ::google::protobuf::int32 uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respLogin) */ {
 public:
  respLogin();
  virtual ~respLogin();

  respLogin(const respLogin& from);

  inline respLogin& operator=(const respLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respLogin(respLogin&& from) noexcept
    : respLogin() {
    *this = ::std::move(from);
  }

  inline respLogin& operator=(respLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respLogin* internal_default_instance() {
    return reinterpret_cast<const respLogin*>(
               &_respLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(respLogin* other);
  friend void swap(respLogin& a, respLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respLogin* New() const final {
    return CreateMaybeMessage<respLogin>(NULL);
  }

  respLogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respLogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respLogin& from);
  void MergeFrom(const respLogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respLogin_eLoginRetCode eLoginRetCode;
  static const eLoginRetCode success =
    respLogin_eLoginRetCode_success;
  static const eLoginRetCode server_busy =
    respLogin_eLoginRetCode_server_busy;
  static const eLoginRetCode server_limit_reached =
    respLogin_eLoginRetCode_server_limit_reached;
  static const eLoginRetCode UID_error =
    respLogin_eLoginRetCode_UID_error;
  static const eLoginRetCode incorrect_password =
    respLogin_eLoginRetCode_incorrect_password;
  static inline bool eLoginRetCode_IsValid(int value) {
    return respLogin_eLoginRetCode_IsValid(value);
  }
  static const eLoginRetCode eLoginRetCode_MIN =
    respLogin_eLoginRetCode_eLoginRetCode_MIN;
  static const eLoginRetCode eLoginRetCode_MAX =
    respLogin_eLoginRetCode_eLoginRetCode_MAX;
  static const int eLoginRetCode_ARRAYSIZE =
    respLogin_eLoginRetCode_eLoginRetCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eLoginRetCode_descriptor() {
    return respLogin_eLoginRetCode_descriptor();
  }
  static inline const ::std::string& eLoginRetCode_Name(eLoginRetCode value) {
    return respLogin_eLoginRetCode_Name(value);
  }
  static inline bool eLoginRetCode_Parse(const ::std::string& name,
      eLoginRetCode* value) {
    return respLogin_eLoginRetCode_Parse(name, value);
  }

  typedef respLogin_eCltType eCltType;
  static const eCltType client =
    respLogin_eCltType_client;
  static const eCltType androidClient =
    respLogin_eCltType_androidClient;
  static const eCltType LSM =
    respLogin_eCltType_LSM;
  static inline bool eCltType_IsValid(int value) {
    return respLogin_eCltType_IsValid(value);
  }
  static const eCltType eCltType_MIN =
    respLogin_eCltType_eCltType_MIN;
  static const eCltType eCltType_MAX =
    respLogin_eCltType_eCltType_MAX;
  static const int eCltType_ARRAYSIZE =
    respLogin_eCltType_eCltType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCltType_descriptor() {
    return respLogin_eCltType_descriptor();
  }
  static inline const ::std::string& eCltType_Name(eCltType value) {
    return respLogin_eCltType_Name(value);
  }
  static inline bool eCltType_Parse(const ::std::string& name,
      eCltType* value) {
    return respLogin_eCltType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .DDRCommProto.respLogin.eLoginRetCode retcode = 1;
  void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  ::DDRCommProto::respLogin_eLoginRetCode retcode() const;
  void set_retcode(::DDRCommProto::respLogin_eLoginRetCode value);

  // .DDRCommProto.respLogin.eCltType yourRole = 2;
  void clear_yourrole();
  static const int kYourRoleFieldNumber = 2;
  ::DDRCommProto::respLogin_eCltType yourrole() const;
  void set_yourrole(::DDRCommProto::respLogin_eCltType value);

  // int32 UID = 3;
  void clear_uid();
  static const int kUIDFieldNumber = 3;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int retcode_;
  int yourrole_;
  ::google::protobuf::int32 uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyTerminalAccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyTerminalAccess) */ {
 public:
  notifyTerminalAccess();
  virtual ~notifyTerminalAccess();

  notifyTerminalAccess(const notifyTerminalAccess& from);

  inline notifyTerminalAccess& operator=(const notifyTerminalAccess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyTerminalAccess(notifyTerminalAccess&& from) noexcept
    : notifyTerminalAccess() {
    *this = ::std::move(from);
  }

  inline notifyTerminalAccess& operator=(notifyTerminalAccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyTerminalAccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyTerminalAccess* internal_default_instance() {
    return reinterpret_cast<const notifyTerminalAccess*>(
               &_notifyTerminalAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(notifyTerminalAccess* other);
  friend void swap(notifyTerminalAccess& a, notifyTerminalAccess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyTerminalAccess* New() const final {
    return CreateMaybeMessage<notifyTerminalAccess>(NULL);
  }

  notifyTerminalAccess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyTerminalAccess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyTerminalAccess& from);
  void MergeFrom(const notifyTerminalAccess& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyTerminalAccess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string nameLSMs = 5;
  int namelsms_size() const;
  void clear_namelsms();
  static const int kNameLSMsFieldNumber = 5;
  const ::std::string& namelsms(int index) const;
  ::std::string* mutable_namelsms(int index);
  void set_namelsms(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_namelsms(int index, ::std::string&& value);
  #endif
  void set_namelsms(int index, const char* value);
  void set_namelsms(int index, const char* value, size_t size);
  ::std::string* add_namelsms();
  void add_namelsms(const ::std::string& value);
  #if LANG_CXX11
  void add_namelsms(::std::string&& value);
  #endif
  void add_namelsms(const char* value);
  void add_namelsms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& namelsms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_namelsms();

  // int32 bRRConnected2RS = 1;
  void clear_brrconnected2rs();
  static const int kBRRConnected2RSFieldNumber = 1;
  ::google::protobuf::int32 brrconnected2rs() const;
  void set_brrconnected2rs(::google::protobuf::int32 value);

  // int32 bOp = 2;
  void clear_bop();
  static const int kBOpFieldNumber = 2;
  ::google::protobuf::int32 bop() const;
  void set_bop(::google::protobuf::int32 value);

  // int32 nMonitors = 3;
  void clear_nmonitors();
  static const int kNMonitorsFieldNumber = 3;
  ::google::protobuf::int32 nmonitors() const;
  void set_nmonitors(::google::protobuf::int32 value);

  // int32 nClients = 4;
  void clear_nclients();
  static const int kNClientsFieldNumber = 4;
  ::google::protobuf::int32 nclients() const;
  void set_nclients(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyTerminalAccess)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> namelsms_;
  ::google::protobuf::int32 brrconnected2rs_;
  ::google::protobuf::int32 bop_;
  ::google::protobuf::int32 nmonitors_;
  ::google::protobuf::int32 nclients_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifySerAccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifySerAccess) */ {
 public:
  notifySerAccess();
  virtual ~notifySerAccess();

  notifySerAccess(const notifySerAccess& from);

  inline notifySerAccess& operator=(const notifySerAccess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifySerAccess(notifySerAccess&& from) noexcept
    : notifySerAccess() {
    *this = ::std::move(from);
  }

  inline notifySerAccess& operator=(notifySerAccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifySerAccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifySerAccess* internal_default_instance() {
    return reinterpret_cast<const notifySerAccess*>(
               &_notifySerAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(notifySerAccess* other);
  friend void swap(notifySerAccess& a, notifySerAccess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifySerAccess* New() const final {
    return CreateMaybeMessage<notifySerAccess>(NULL);
  }

  notifySerAccess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifySerAccess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifySerAccess& from);
  void MergeFrom(const notifySerAccess& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifySerAccess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string namesLSM = 7;
  int nameslsm_size() const;
  void clear_nameslsm();
  static const int kNamesLSMFieldNumber = 7;
  const ::std::string& nameslsm(int index) const;
  ::std::string* mutable_nameslsm(int index);
  void set_nameslsm(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_nameslsm(int index, ::std::string&& value);
  #endif
  void set_nameslsm(int index, const char* value);
  void set_nameslsm(int index, const char* value, size_t size);
  ::std::string* add_nameslsm();
  void add_nameslsm(const ::std::string& value);
  #if LANG_CXX11
  void add_nameslsm(::std::string&& value);
  #endif
  void add_nameslsm(const char* value);
  void add_nameslsm(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& nameslsm() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nameslsm();

  // int32 nMonitors = 1;
  void clear_nmonitors();
  static const int kNMonitorsFieldNumber = 1;
  ::google::protobuf::int32 nmonitors() const;
  void set_nmonitors(::google::protobuf::int32 value);

  // int32 mTopOpLv = 2;
  void clear_mtopoplv();
  static const int kMTopOpLvFieldNumber = 2;
  ::google::protobuf::int32 mtopoplv() const;
  void set_mtopoplv(::google::protobuf::int32 value);

  // int32 mTopOpTime = 3;
  void clear_mtopoptime();
  static const int kMTopOpTimeFieldNumber = 3;
  ::google::protobuf::int32 mtopoptime() const;
  void set_mtopoptime(::google::protobuf::int32 value);

  // int32 nClients = 4;
  void clear_nclients();
  static const int kNClientsFieldNumber = 4;
  ::google::protobuf::int32 nclients() const;
  void set_nclients(::google::protobuf::int32 value);

  // int64 cTopOpTime = 6;
  void clear_ctopoptime();
  static const int kCTopOpTimeFieldNumber = 6;
  ::google::protobuf::int64 ctopoptime() const;
  void set_ctopoptime(::google::protobuf::int64 value);

  // int32 cTopOpLv = 5;
  void clear_ctopoplv();
  static const int kCTopOpLvFieldNumber = 5;
  ::google::protobuf::int32 ctopoplv() const;
  void set_ctopoplv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifySerAccess)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nameslsm_;
  ::google::protobuf::int32 nmonitors_;
  ::google::protobuf::int32 mtopoplv_;
  ::google::protobuf::int32 mtopoptime_;
  ::google::protobuf::int32 nclients_;
  ::google::protobuf::int64 ctopoptime_;
  ::google::protobuf::int32 ctopoplv_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyAVStream_fullChannelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyAVStream.fullChannelInfo) */ {
 public:
  notifyAVStream_fullChannelInfo();
  virtual ~notifyAVStream_fullChannelInfo();

  notifyAVStream_fullChannelInfo(const notifyAVStream_fullChannelInfo& from);

  inline notifyAVStream_fullChannelInfo& operator=(const notifyAVStream_fullChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyAVStream_fullChannelInfo(notifyAVStream_fullChannelInfo&& from) noexcept
    : notifyAVStream_fullChannelInfo() {
    *this = ::std::move(from);
  }

  inline notifyAVStream_fullChannelInfo& operator=(notifyAVStream_fullChannelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyAVStream_fullChannelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyAVStream_fullChannelInfo* internal_default_instance() {
    return reinterpret_cast<const notifyAVStream_fullChannelInfo*>(
               &_notifyAVStream_fullChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(notifyAVStream_fullChannelInfo* other);
  friend void swap(notifyAVStream_fullChannelInfo& a, notifyAVStream_fullChannelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyAVStream_fullChannelInfo* New() const final {
    return CreateMaybeMessage<notifyAVStream_fullChannelInfo>(NULL);
  }

  notifyAVStream_fullChannelInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyAVStream_fullChannelInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyAVStream_fullChannelInfo& from);
  void MergeFrom(const notifyAVStream_fullChannelInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyAVStream_fullChannelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string localResAccStr = 3;
  void clear_localresaccstr();
  static const int kLocalResAccStrFieldNumber = 3;
  const ::std::string& localresaccstr() const;
  void set_localresaccstr(const ::std::string& value);
  #if LANG_CXX11
  void set_localresaccstr(::std::string&& value);
  #endif
  void set_localresaccstr(const char* value);
  void set_localresaccstr(const char* value, size_t size);
  ::std::string* mutable_localresaccstr();
  ::std::string* release_localresaccstr();
  void set_allocated_localresaccstr(::std::string* localresaccstr);

  // string channelDescription = 4;
  void clear_channeldescription();
  static const int kChannelDescriptionFieldNumber = 4;
  const ::std::string& channeldescription() const;
  void set_channeldescription(const ::std::string& value);
  #if LANG_CXX11
  void set_channeldescription(::std::string&& value);
  #endif
  void set_channeldescription(const char* value);
  void set_channeldescription(const char* value, size_t size);
  ::std::string* mutable_channeldescription();
  ::std::string* release_channeldescription();
  void set_allocated_channeldescription(::std::string* channeldescription);

  // string remotePass = 8;
  void clear_remotepass();
  static const int kRemotePassFieldNumber = 8;
  const ::std::string& remotepass() const;
  void set_remotepass(const ::std::string& value);
  #if LANG_CXX11
  void set_remotepass(::std::string&& value);
  #endif
  void set_remotepass(const char* value);
  void set_remotepass(const char* value, size_t size);
  ::std::string* mutable_remotepass();
  ::std::string* release_remotepass();
  void set_allocated_remotepass(::std::string* remotepass);

  // int32 devType = 1;
  void clear_devtype();
  static const int kDevTypeFieldNumber = 1;
  ::google::protobuf::int32 devtype() const;
  void set_devtype(::google::protobuf::int32 value);

  // int32 dataType = 2;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 2;
  ::google::protobuf::int32 datatype() const;
  void set_datatype(::google::protobuf::int32 value);

  // int64 remoteIP = 6;
  void clear_remoteip();
  static const int kRemoteIPFieldNumber = 6;
  ::google::protobuf::int64 remoteip() const;
  void set_remoteip(::google::protobuf::int64 value);

  // int32 bwReq = 5;
  void clear_bwreq();
  static const int kBwReqFieldNumber = 5;
  ::google::protobuf::int32 bwreq() const;
  void set_bwreq(::google::protobuf::int32 value);

  // int32 remotePort = 7;
  void clear_remoteport();
  static const int kRemotePortFieldNumber = 7;
  ::google::protobuf::int32 remoteport() const;
  void set_remoteport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyAVStream.fullChannelInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr localresaccstr_;
  ::google::protobuf::internal::ArenaStringPtr channeldescription_;
  ::google::protobuf::internal::ArenaStringPtr remotepass_;
  ::google::protobuf::int32 devtype_;
  ::google::protobuf::int32 datatype_;
  ::google::protobuf::int64 remoteip_;
  ::google::protobuf::int32 bwreq_;
  ::google::protobuf::int32 remoteport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyAVStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyAVStream) */ {
 public:
  notifyAVStream();
  virtual ~notifyAVStream();

  notifyAVStream(const notifyAVStream& from);

  inline notifyAVStream& operator=(const notifyAVStream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyAVStream(notifyAVStream&& from) noexcept
    : notifyAVStream() {
    *this = ::std::move(from);
  }

  inline notifyAVStream& operator=(notifyAVStream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyAVStream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyAVStream* internal_default_instance() {
    return reinterpret_cast<const notifyAVStream*>(
               &_notifyAVStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(notifyAVStream* other);
  friend void swap(notifyAVStream& a, notifyAVStream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyAVStream* New() const final {
    return CreateMaybeMessage<notifyAVStream>(NULL);
  }

  notifyAVStream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyAVStream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyAVStream& from);
  void MergeFrom(const notifyAVStream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyAVStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef notifyAVStream_fullChannelInfo fullChannelInfo;

  // accessors -------------------------------------------------------

  // repeated .DDRCommProto.notifyAVStream.fullChannelInfo robotMonitorChannels = 2;
  int robotmonitorchannels_size() const;
  void clear_robotmonitorchannels();
  static const int kRobotMonitorChannelsFieldNumber = 2;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* mutable_robotmonitorchannels(int index);
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >*
      mutable_robotmonitorchannels();
  const ::DDRCommProto::notifyAVStream_fullChannelInfo& robotmonitorchannels(int index) const;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* add_robotmonitorchannels();
  const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >&
      robotmonitorchannels() const;

  // .DDRCommProto.notifyAVStream.fullChannelInfo reservedChannel = 1;
  bool has_reservedchannel() const;
  void clear_reservedchannel();
  static const int kReservedChannelFieldNumber = 1;
  private:
  const ::DDRCommProto::notifyAVStream_fullChannelInfo& _internal_reservedchannel() const;
  public:
  const ::DDRCommProto::notifyAVStream_fullChannelInfo& reservedchannel() const;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* release_reservedchannel();
  ::DDRCommProto::notifyAVStream_fullChannelInfo* mutable_reservedchannel();
  void set_allocated_reservedchannel(::DDRCommProto::notifyAVStream_fullChannelInfo* reservedchannel);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyAVStream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo > robotmonitorchannels_;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* reservedchannel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqTalk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqTalk) */ {
 public:
  reqTalk();
  virtual ~reqTalk();

  reqTalk(const reqTalk& from);

  inline reqTalk& operator=(const reqTalk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqTalk(reqTalk&& from) noexcept
    : reqTalk() {
    *this = ::std::move(from);
  }

  inline reqTalk& operator=(reqTalk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqTalk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqTalk* internal_default_instance() {
    return reinterpret_cast<const reqTalk*>(
               &_reqTalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(reqTalk* other);
  friend void swap(reqTalk& a, reqTalk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqTalk* New() const final {
    return CreateMaybeMessage<reqTalk>(NULL);
  }

  reqTalk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqTalk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqTalk& from);
  void MergeFrom(const reqTalk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqTalk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqTalk_eCallerType eCallerType;
  static const eCallerType client =
    reqTalk_eCallerType_client;
  static const eCallerType monitor =
    reqTalk_eCallerType_monitor;
  static const eCallerType robot_LSM =
    reqTalk_eCallerType_robot_LSM;
  static inline bool eCallerType_IsValid(int value) {
    return reqTalk_eCallerType_IsValid(value);
  }
  static const eCallerType eCallerType_MIN =
    reqTalk_eCallerType_eCallerType_MIN;
  static const eCallerType eCallerType_MAX =
    reqTalk_eCallerType_eCallerType_MAX;
  static const int eCallerType_ARRAYSIZE =
    reqTalk_eCallerType_eCallerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCallerType_descriptor() {
    return reqTalk_eCallerType_descriptor();
  }
  static inline const ::std::string& eCallerType_Name(eCallerType value) {
    return reqTalk_eCallerType_Name(value);
  }
  static inline bool eCallerType_Parse(const ::std::string& name,
      eCallerType* value) {
    return reqTalk_eCallerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string localTalkAddr = 4;
  int localtalkaddr_size() const;
  void clear_localtalkaddr();
  static const int kLocalTalkAddrFieldNumber = 4;
  const ::std::string& localtalkaddr(int index) const;
  ::std::string* mutable_localtalkaddr(int index);
  void set_localtalkaddr(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_localtalkaddr(int index, ::std::string&& value);
  #endif
  void set_localtalkaddr(int index, const char* value);
  void set_localtalkaddr(int index, const char* value, size_t size);
  ::std::string* add_localtalkaddr();
  void add_localtalkaddr(const ::std::string& value);
  #if LANG_CXX11
  void add_localtalkaddr(::std::string&& value);
  #endif
  void add_localtalkaddr(const char* value);
  void add_localtalkaddr(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& localtalkaddr() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_localtalkaddr();

  // .DDRCommProto.reqTalk.eCallerType callerType = 1;
  void clear_callertype();
  static const int kCallerTypeFieldNumber = 1;
  ::DDRCommProto::reqTalk_eCallerType callertype() const;
  void set_callertype(::DDRCommProto::reqTalk_eCallerType value);

  // int32 talkID = 2;
  void clear_talkid();
  static const int kTalkIDFieldNumber = 2;
  ::google::protobuf::int32 talkid() const;
  void set_talkid(::google::protobuf::int32 value);

  // int32 avType = 3;
  void clear_avtype();
  static const int kAvTypeFieldNumber = 3;
  ::google::protobuf::int32 avtype() const;
  void set_avtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqTalk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> localtalkaddr_;
  int callertype_;
  ::google::protobuf::int32 talkid_;
  ::google::protobuf::int32 avtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respTalk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respTalk) */ {
 public:
  respTalk();
  virtual ~respTalk();

  respTalk(const respTalk& from);

  inline respTalk& operator=(const respTalk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respTalk(respTalk&& from) noexcept
    : respTalk() {
    *this = ::std::move(from);
  }

  inline respTalk& operator=(respTalk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respTalk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respTalk* internal_default_instance() {
    return reinterpret_cast<const respTalk*>(
               &_respTalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(respTalk* other);
  friend void swap(respTalk& a, respTalk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respTalk* New() const final {
    return CreateMaybeMessage<respTalk>(NULL);
  }

  respTalk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respTalk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respTalk& from);
  void MergeFrom(const respTalk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respTalk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respTalk_eReceiverType eReceiverType;
  static const eReceiverType client =
    respTalk_eReceiverType_client;
  static const eReceiverType monitor =
    respTalk_eReceiverType_monitor;
  static const eReceiverType robot_LSM =
    respTalk_eReceiverType_robot_LSM;
  static inline bool eReceiverType_IsValid(int value) {
    return respTalk_eReceiverType_IsValid(value);
  }
  static const eReceiverType eReceiverType_MIN =
    respTalk_eReceiverType_eReceiverType_MIN;
  static const eReceiverType eReceiverType_MAX =
    respTalk_eReceiverType_eReceiverType_MAX;
  static const int eReceiverType_ARRAYSIZE =
    respTalk_eReceiverType_eReceiverType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eReceiverType_descriptor() {
    return respTalk_eReceiverType_descriptor();
  }
  static inline const ::std::string& eReceiverType_Name(eReceiverType value) {
    return respTalk_eReceiverType_Name(value);
  }
  static inline bool eReceiverType_Parse(const ::std::string& name,
      eReceiverType* value) {
    return respTalk_eReceiverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .DDRCommProto.respTalk.eReceiverType receiverType = 1;
  void clear_receivertype();
  static const int kReceiverTypeFieldNumber = 1;
  ::DDRCommProto::respTalk_eReceiverType receivertype() const;
  void set_receivertype(::DDRCommProto::respTalk_eReceiverType value);

  // int32 talkID = 2;
  void clear_talkid();
  static const int kTalkIDFieldNumber = 2;
  ::google::protobuf::int32 talkid() const;
  void set_talkid(::google::protobuf::int32 value);

  // int32 avType = 3;
  void clear_avtype();
  static const int kAvTypeFieldNumber = 3;
  ::google::protobuf::int32 avtype() const;
  void set_avtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respTalk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int receivertype_;
  ::google::protobuf::int32 talkid_;
  ::google::protobuf::int32 avtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqTalkHB : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqTalkHB) */ {
 public:
  reqTalkHB();
  virtual ~reqTalkHB();

  reqTalkHB(const reqTalkHB& from);

  inline reqTalkHB& operator=(const reqTalkHB& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqTalkHB(reqTalkHB&& from) noexcept
    : reqTalkHB() {
    *this = ::std::move(from);
  }

  inline reqTalkHB& operator=(reqTalkHB&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqTalkHB& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqTalkHB* internal_default_instance() {
    return reinterpret_cast<const reqTalkHB*>(
               &_reqTalkHB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(reqTalkHB* other);
  friend void swap(reqTalkHB& a, reqTalkHB& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqTalkHB* New() const final {
    return CreateMaybeMessage<reqTalkHB>(NULL);
  }

  reqTalkHB* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqTalkHB>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqTalkHB& from);
  void MergeFrom(const reqTalkHB& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqTalkHB* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 callerTalkID = 1;
  void clear_callertalkid();
  static const int kCallerTalkIDFieldNumber = 1;
  ::google::protobuf::int32 callertalkid() const;
  void set_callertalkid(::google::protobuf::int32 value);

  // int32 receiverTalkID = 2;
  void clear_receivertalkid();
  static const int kReceiverTalkIDFieldNumber = 2;
  ::google::protobuf::int32 receivertalkid() const;
  void set_receivertalkid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqTalkHB)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 callertalkid_;
  ::google::protobuf::int32 receivertalkid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqCmd) */ {
 public:
  reqCmd();
  virtual ~reqCmd();

  reqCmd(const reqCmd& from);

  inline reqCmd& operator=(const reqCmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqCmd(reqCmd&& from) noexcept
    : reqCmd() {
    *this = ::std::move(from);
  }

  inline reqCmd& operator=(reqCmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqCmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqCmd* internal_default_instance() {
    return reinterpret_cast<const reqCmd*>(
               &_reqCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(reqCmd* other);
  friend void swap(reqCmd& a, reqCmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqCmd* New() const final {
    return CreateMaybeMessage<reqCmd>(NULL);
  }

  reqCmd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqCmd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqCmd& from);
  void MergeFrom(const reqCmd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cmdMsg = 2;
  void clear_cmdmsg();
  static const int kCmdMsgFieldNumber = 2;
  const ::std::string& cmdmsg() const;
  void set_cmdmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_cmdmsg(::std::string&& value);
  #endif
  void set_cmdmsg(const char* value);
  void set_cmdmsg(const char* value, size_t size);
  ::std::string* mutable_cmdmsg();
  ::std::string* release_cmdmsg();
  void set_allocated_cmdmsg(::std::string* cmdmsg);

  // int64 cmdID = 1;
  void clear_cmdid();
  static const int kCmdIDFieldNumber = 1;
  ::google::protobuf::int64 cmdid() const;
  void set_cmdid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cmdmsg_;
  ::google::protobuf::int64 cmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respCmd) */ {
 public:
  respCmd();
  virtual ~respCmd();

  respCmd(const respCmd& from);

  inline respCmd& operator=(const respCmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respCmd(respCmd&& from) noexcept
    : respCmd() {
    *this = ::std::move(from);
  }

  inline respCmd& operator=(respCmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respCmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respCmd* internal_default_instance() {
    return reinterpret_cast<const respCmd*>(
               &_respCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(respCmd* other);
  friend void swap(respCmd& a, respCmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respCmd* New() const final {
    return CreateMaybeMessage<respCmd>(NULL);
  }

  respCmd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respCmd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respCmd& from);
  void MergeFrom(const respCmd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string respMsg = 2;
  void clear_respmsg();
  static const int kRespMsgFieldNumber = 2;
  const ::std::string& respmsg() const;
  void set_respmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_respmsg(::std::string&& value);
  #endif
  void set_respmsg(const char* value);
  void set_respmsg(const char* value, size_t size);
  ::std::string* mutable_respmsg();
  ::std::string* release_respmsg();
  void set_allocated_respmsg(::std::string* respmsg);

  // int64 cmdID = 1;
  void clear_cmdid();
  static const int kCmdIDFieldNumber = 1;
  ::google::protobuf::int64 cmdid() const;
  void set_cmdid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr respmsg_;
  ::google::protobuf::int64 cmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqFile) */ {
 public:
  reqFile();
  virtual ~reqFile();

  reqFile(const reqFile& from);

  inline reqFile& operator=(const reqFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqFile(reqFile&& from) noexcept
    : reqFile() {
    *this = ::std::move(from);
  }

  inline reqFile& operator=(reqFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqFile* internal_default_instance() {
    return reinterpret_cast<const reqFile*>(
               &_reqFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(reqFile* other);
  friend void swap(reqFile& a, reqFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqFile* New() const final {
    return CreateMaybeMessage<reqFile>(NULL);
  }

  reqFile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqFile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqFile& from);
  void MergeFrom(const reqFile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqFile_eFileTypes eFileTypes;
  static const eFileTypes FileContents =
    reqFile_eFileTypes_FileContents;
  static const eFileTypes FileList =
    reqFile_eFileTypes_FileList;
  static const eFileTypes FolderFlist =
    reqFile_eFileTypes_FolderFlist;
  static inline bool eFileTypes_IsValid(int value) {
    return reqFile_eFileTypes_IsValid(value);
  }
  static const eFileTypes eFileTypes_MIN =
    reqFile_eFileTypes_eFileTypes_MIN;
  static const eFileTypes eFileTypes_MAX =
    reqFile_eFileTypes_eFileTypes_MAX;
  static const int eFileTypes_ARRAYSIZE =
    reqFile_eFileTypes_eFileTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFileTypes_descriptor() {
    return reqFile_eFileTypes_descriptor();
  }
  static inline const ::std::string& eFileTypes_Name(eFileTypes value) {
    return reqFile_eFileTypes_Name(value);
  }
  static inline bool eFileTypes_Parse(const ::std::string& name,
      eFileTypes* value) {
    return reqFile_eFileTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string fileNames = 3;
  int filenames_size() const;
  void clear_filenames();
  static const int kFileNamesFieldNumber = 3;
  const ::std::string& filenames(int index) const;
  ::std::string* mutable_filenames(int index);
  void set_filenames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filenames(int index, ::std::string&& value);
  #endif
  void set_filenames(int index, const char* value);
  void set_filenames(int index, const char* value, size_t size);
  ::std::string* add_filenames();
  void add_filenames(const ::std::string& value);
  #if LANG_CXX11
  void add_filenames(::std::string&& value);
  #endif
  void add_filenames(const char* value);
  void add_filenames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filenames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filenames();

  // string tarLSMName = 1;
  void clear_tarlsmname();
  static const int kTarLSMNameFieldNumber = 1;
  const ::std::string& tarlsmname() const;
  void set_tarlsmname(const ::std::string& value);
  #if LANG_CXX11
  void set_tarlsmname(::std::string&& value);
  #endif
  void set_tarlsmname(const char* value);
  void set_tarlsmname(const char* value, size_t size);
  ::std::string* mutable_tarlsmname();
  ::std::string* release_tarlsmname();
  void set_allocated_tarlsmname(::std::string* tarlsmname);

  // .DDRCommProto.reqFile.eFileTypes fileType = 2;
  void clear_filetype();
  static const int kFileTypeFieldNumber = 2;
  ::DDRCommProto::reqFile_eFileTypes filetype() const;
  void set_filetype(::DDRCommProto::reqFile_eFileTypes value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filenames_;
  ::google::protobuf::internal::ArenaStringPtr tarlsmname_;
  int filetype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respFile) */ {
 public:
  respFile();
  virtual ~respFile();

  respFile(const respFile& from);

  inline respFile& operator=(const respFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respFile(respFile&& from) noexcept
    : respFile() {
    *this = ::std::move(from);
  }

  inline respFile& operator=(respFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respFile* internal_default_instance() {
    return reinterpret_cast<const respFile*>(
               &_respFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(respFile* other);
  friend void swap(respFile& a, respFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respFile* New() const final {
    return CreateMaybeMessage<respFile>(NULL);
  }

  respFile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respFile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respFile& from);
  void MergeFrom(const respFile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respFile_eFileTypes eFileTypes;
  static const eFileTypes FileContents =
    respFile_eFileTypes_FileContents;
  static const eFileTypes FileList =
    respFile_eFileTypes_FileList;
  static const eFileTypes FolderFlist =
    respFile_eFileTypes_FolderFlist;
  static inline bool eFileTypes_IsValid(int value) {
    return respFile_eFileTypes_IsValid(value);
  }
  static const eFileTypes eFileTypes_MIN =
    respFile_eFileTypes_eFileTypes_MIN;
  static const eFileTypes eFileTypes_MAX =
    respFile_eFileTypes_eFileTypes_MAX;
  static const int eFileTypes_ARRAYSIZE =
    respFile_eFileTypes_eFileTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFileTypes_descriptor() {
    return respFile_eFileTypes_descriptor();
  }
  static inline const ::std::string& eFileTypes_Name(eFileTypes value) {
    return respFile_eFileTypes_Name(value);
  }
  static inline bool eFileTypes_Parse(const ::std::string& name,
      eFileTypes* value) {
    return respFile_eFileTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string fileNames = 3;
  int filenames_size() const;
  void clear_filenames();
  static const int kFileNamesFieldNumber = 3;
  const ::std::string& filenames(int index) const;
  ::std::string* mutable_filenames(int index);
  void set_filenames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filenames(int index, ::std::string&& value);
  #endif
  void set_filenames(int index, const char* value);
  void set_filenames(int index, const char* value, size_t size);
  ::std::string* add_filenames();
  void add_filenames(const ::std::string& value);
  #if LANG_CXX11
  void add_filenames(::std::string&& value);
  #endif
  void add_filenames(const char* value);
  void add_filenames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filenames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filenames();

  // repeated string fileContents = 4;
  int filecontents_size() const;
  void clear_filecontents();
  static const int kFileContentsFieldNumber = 4;
  const ::std::string& filecontents(int index) const;
  ::std::string* mutable_filecontents(int index);
  void set_filecontents(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filecontents(int index, ::std::string&& value);
  #endif
  void set_filecontents(int index, const char* value);
  void set_filecontents(int index, const char* value, size_t size);
  ::std::string* add_filecontents();
  void add_filecontents(const ::std::string& value);
  #if LANG_CXX11
  void add_filecontents(::std::string&& value);
  #endif
  void add_filecontents(const char* value);
  void add_filecontents(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filecontents() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filecontents();

  // string tarLSMName = 1;
  void clear_tarlsmname();
  static const int kTarLSMNameFieldNumber = 1;
  const ::std::string& tarlsmname() const;
  void set_tarlsmname(const ::std::string& value);
  #if LANG_CXX11
  void set_tarlsmname(::std::string&& value);
  #endif
  void set_tarlsmname(const char* value);
  void set_tarlsmname(const char* value, size_t size);
  ::std::string* mutable_tarlsmname();
  ::std::string* release_tarlsmname();
  void set_allocated_tarlsmname(::std::string* tarlsmname);

  // .DDRCommProto.respFile.eFileTypes fileType = 2;
  void clear_filetype();
  static const int kFileTypeFieldNumber = 2;
  ::DDRCommProto::respFile_eFileTypes filetype() const;
  void set_filetype(::DDRCommProto::respFile_eFileTypes value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filenames_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filecontents_;
  ::google::protobuf::internal::ArenaStringPtr tarlsmname_;
  int filetype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqFileAddr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqFileAddr) */ {
 public:
  reqFileAddr();
  virtual ~reqFileAddr();

  reqFileAddr(const reqFileAddr& from);

  inline reqFileAddr& operator=(const reqFileAddr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqFileAddr(reqFileAddr&& from) noexcept
    : reqFileAddr() {
    *this = ::std::move(from);
  }

  inline reqFileAddr& operator=(reqFileAddr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqFileAddr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqFileAddr* internal_default_instance() {
    return reinterpret_cast<const reqFileAddr*>(
               &_reqFileAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(reqFileAddr* other);
  friend void swap(reqFileAddr& a, reqFileAddr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqFileAddr* New() const final {
    return CreateMaybeMessage<reqFileAddr>(NULL);
  }

  reqFileAddr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqFileAddr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqFileAddr& from);
  void MergeFrom(const reqFileAddr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqFileAddr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqFileAddr_eFileTypes eFileTypes;
  static const eFileTypes FileContents =
    reqFileAddr_eFileTypes_FileContents;
  static const eFileTypes FileList =
    reqFileAddr_eFileTypes_FileList;
  static const eFileTypes FolderFlist =
    reqFileAddr_eFileTypes_FolderFlist;
  static inline bool eFileTypes_IsValid(int value) {
    return reqFileAddr_eFileTypes_IsValid(value);
  }
  static const eFileTypes eFileTypes_MIN =
    reqFileAddr_eFileTypes_eFileTypes_MIN;
  static const eFileTypes eFileTypes_MAX =
    reqFileAddr_eFileTypes_eFileTypes_MAX;
  static const int eFileTypes_ARRAYSIZE =
    reqFileAddr_eFileTypes_eFileTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFileTypes_descriptor() {
    return reqFileAddr_eFileTypes_descriptor();
  }
  static inline const ::std::string& eFileTypes_Name(eFileTypes value) {
    return reqFileAddr_eFileTypes_Name(value);
  }
  static inline bool eFileTypes_Parse(const ::std::string& name,
      eFileTypes* value) {
    return reqFileAddr_eFileTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string fileNames = 3;
  int filenames_size() const;
  void clear_filenames();
  static const int kFileNamesFieldNumber = 3;
  const ::std::string& filenames(int index) const;
  ::std::string* mutable_filenames(int index);
  void set_filenames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filenames(int index, ::std::string&& value);
  #endif
  void set_filenames(int index, const char* value);
  void set_filenames(int index, const char* value, size_t size);
  ::std::string* add_filenames();
  void add_filenames(const ::std::string& value);
  #if LANG_CXX11
  void add_filenames(::std::string&& value);
  #endif
  void add_filenames(const char* value);
  void add_filenames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filenames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filenames();

  // string tarLSMName = 1;
  void clear_tarlsmname();
  static const int kTarLSMNameFieldNumber = 1;
  const ::std::string& tarlsmname() const;
  void set_tarlsmname(const ::std::string& value);
  #if LANG_CXX11
  void set_tarlsmname(::std::string&& value);
  #endif
  void set_tarlsmname(const char* value);
  void set_tarlsmname(const char* value, size_t size);
  ::std::string* mutable_tarlsmname();
  ::std::string* release_tarlsmname();
  void set_allocated_tarlsmname(::std::string* tarlsmname);

  // .DDRCommProto.reqFileAddr.eFileTypes fileType = 2;
  void clear_filetype();
  static const int kFileTypeFieldNumber = 2;
  ::DDRCommProto::reqFileAddr_eFileTypes filetype() const;
  void set_filetype(::DDRCommProto::reqFileAddr_eFileTypes value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqFileAddr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filenames_;
  ::google::protobuf::internal::ArenaStringPtr tarlsmname_;
  int filetype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respFileAddr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respFileAddr) */ {
 public:
  respFileAddr();
  virtual ~respFileAddr();

  respFileAddr(const respFileAddr& from);

  inline respFileAddr& operator=(const respFileAddr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respFileAddr(respFileAddr&& from) noexcept
    : respFileAddr() {
    *this = ::std::move(from);
  }

  inline respFileAddr& operator=(respFileAddr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respFileAddr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respFileAddr* internal_default_instance() {
    return reinterpret_cast<const respFileAddr*>(
               &_respFileAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(respFileAddr* other);
  friend void swap(respFileAddr& a, respFileAddr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respFileAddr* New() const final {
    return CreateMaybeMessage<respFileAddr>(NULL);
  }

  respFileAddr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respFileAddr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respFileAddr& from);
  void MergeFrom(const respFileAddr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respFileAddr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respFileAddr_eFileTypes eFileTypes;
  static const eFileTypes FileContents =
    respFileAddr_eFileTypes_FileContents;
  static const eFileTypes FileList =
    respFileAddr_eFileTypes_FileList;
  static const eFileTypes FolderFlist =
    respFileAddr_eFileTypes_FolderFlist;
  static inline bool eFileTypes_IsValid(int value) {
    return respFileAddr_eFileTypes_IsValid(value);
  }
  static const eFileTypes eFileTypes_MIN =
    respFileAddr_eFileTypes_eFileTypes_MIN;
  static const eFileTypes eFileTypes_MAX =
    respFileAddr_eFileTypes_eFileTypes_MAX;
  static const int eFileTypes_ARRAYSIZE =
    respFileAddr_eFileTypes_eFileTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFileTypes_descriptor() {
    return respFileAddr_eFileTypes_descriptor();
  }
  static inline const ::std::string& eFileTypes_Name(eFileTypes value) {
    return respFileAddr_eFileTypes_Name(value);
  }
  static inline bool eFileTypes_Parse(const ::std::string& name,
      eFileTypes* value) {
    return respFileAddr_eFileTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string fileNames = 3;
  int filenames_size() const;
  void clear_filenames();
  static const int kFileNamesFieldNumber = 3;
  const ::std::string& filenames(int index) const;
  ::std::string* mutable_filenames(int index);
  void set_filenames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_filenames(int index, ::std::string&& value);
  #endif
  void set_filenames(int index, const char* value);
  void set_filenames(int index, const char* value, size_t size);
  ::std::string* add_filenames();
  void add_filenames(const ::std::string& value);
  #if LANG_CXX11
  void add_filenames(::std::string&& value);
  #endif
  void add_filenames(const char* value);
  void add_filenames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filenames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filenames();

  // repeated string fileAddr = 4;
  int fileaddr_size() const;
  void clear_fileaddr();
  static const int kFileAddrFieldNumber = 4;
  const ::std::string& fileaddr(int index) const;
  ::std::string* mutable_fileaddr(int index);
  void set_fileaddr(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fileaddr(int index, ::std::string&& value);
  #endif
  void set_fileaddr(int index, const char* value);
  void set_fileaddr(int index, const char* value, size_t size);
  ::std::string* add_fileaddr();
  void add_fileaddr(const ::std::string& value);
  #if LANG_CXX11
  void add_fileaddr(::std::string&& value);
  #endif
  void add_fileaddr(const char* value);
  void add_fileaddr(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fileaddr() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fileaddr();

  // string tarLSMName = 1;
  void clear_tarlsmname();
  static const int kTarLSMNameFieldNumber = 1;
  const ::std::string& tarlsmname() const;
  void set_tarlsmname(const ::std::string& value);
  #if LANG_CXX11
  void set_tarlsmname(::std::string&& value);
  #endif
  void set_tarlsmname(const char* value);
  void set_tarlsmname(const char* value, size_t size);
  ::std::string* mutable_tarlsmname();
  ::std::string* release_tarlsmname();
  void set_allocated_tarlsmname(::std::string* tarlsmname);

  // .DDRCommProto.respFileAddr.eFileTypes fileType = 2;
  void clear_filetype();
  static const int kFileTypeFieldNumber = 2;
  ::DDRCommProto::respFileAddr_eFileTypes filetype() const;
  void set_filetype(::DDRCommProto::respFileAddr_eFileTypes value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respFileAddr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filenames_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fileaddr_;
  ::google::protobuf::internal::ArenaStringPtr tarlsmname_;
  int filetype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqStatus) */ {
 public:
  reqStatus();
  virtual ~reqStatus();

  reqStatus(const reqStatus& from);

  inline reqStatus& operator=(const reqStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqStatus(reqStatus&& from) noexcept
    : reqStatus() {
    *this = ::std::move(from);
  }

  inline reqStatus& operator=(reqStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqStatus* internal_default_instance() {
    return reinterpret_cast<const reqStatus*>(
               &_reqStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(reqStatus* other);
  friend void swap(reqStatus& a, reqStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqStatus* New() const final {
    return CreateMaybeMessage<reqStatus>(NULL);
  }

  reqStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqStatus& from);
  void MergeFrom(const reqStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string statusMsg = 1;
  void clear_statusmsg();
  static const int kStatusMsgFieldNumber = 1;
  const ::std::string& statusmsg() const;
  void set_statusmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_statusmsg(::std::string&& value);
  #endif
  void set_statusmsg(const char* value);
  void set_statusmsg(const char* value, size_t size);
  ::std::string* mutable_statusmsg();
  ::std::string* release_statusmsg();
  void set_allocated_statusmsg(::std::string* statusmsg);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr statusmsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqAlarm) */ {
 public:
  reqAlarm();
  virtual ~reqAlarm();

  reqAlarm(const reqAlarm& from);

  inline reqAlarm& operator=(const reqAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqAlarm(reqAlarm&& from) noexcept
    : reqAlarm() {
    *this = ::std::move(from);
  }

  inline reqAlarm& operator=(reqAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqAlarm* internal_default_instance() {
    return reinterpret_cast<const reqAlarm*>(
               &_reqAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(reqAlarm* other);
  friend void swap(reqAlarm& a, reqAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqAlarm* New() const final {
    return CreateMaybeMessage<reqAlarm>(NULL);
  }

  reqAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqAlarm& from);
  void MergeFrom(const reqAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string alarmMsg = 1;
  void clear_alarmmsg();
  static const int kAlarmMsgFieldNumber = 1;
  const ::std::string& alarmmsg() const;
  void set_alarmmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_alarmmsg(::std::string&& value);
  #endif
  void set_alarmmsg(const char* value);
  void set_alarmmsg(const char* value, size_t size);
  ::std::string* mutable_alarmmsg();
  ::std::string* release_alarmmsg();
  void set_allocated_alarmmsg(::std::string* alarmmsg);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqAlarm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr alarmmsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqTextChat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqTextChat) */ {
 public:
  reqTextChat();
  virtual ~reqTextChat();

  reqTextChat(const reqTextChat& from);

  inline reqTextChat& operator=(const reqTextChat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqTextChat(reqTextChat&& from) noexcept
    : reqTextChat() {
    *this = ::std::move(from);
  }

  inline reqTextChat& operator=(reqTextChat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqTextChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqTextChat* internal_default_instance() {
    return reinterpret_cast<const reqTextChat*>(
               &_reqTextChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(reqTextChat* other);
  friend void swap(reqTextChat& a, reqTextChat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqTextChat* New() const final {
    return CreateMaybeMessage<reqTextChat>(NULL);
  }

  reqTextChat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqTextChat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqTextChat& from);
  void MergeFrom(const reqTextChat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqTextChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chatText = 1;
  void clear_chattext();
  static const int kChatTextFieldNumber = 1;
  const ::std::string& chattext() const;
  void set_chattext(const ::std::string& value);
  #if LANG_CXX11
  void set_chattext(::std::string&& value);
  #endif
  void set_chattext(const char* value);
  void set_chattext(const char* value, size_t size);
  ::std::string* mutable_chattext();
  ::std::string* release_chattext();
  void set_allocated_chattext(::std::string* chattext);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqTextChat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chattext_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonHeader

// string bodyType = 1;
inline void CommonHeader::clear_bodytype() {
  bodytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommonHeader::bodytype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.bodyType)
  return bodytype_.GetNoArena();
}
inline void CommonHeader::set_bodytype(const ::std::string& value) {
  
  bodytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.bodyType)
}
#if LANG_CXX11
inline void CommonHeader::set_bodytype(::std::string&& value) {
  
  bodytype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.CommonHeader.bodyType)
}
#endif
inline void CommonHeader::set_bodytype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bodytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.CommonHeader.bodyType)
}
inline void CommonHeader::set_bodytype(const char* value, size_t size) {
  
  bodytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.CommonHeader.bodyType)
}
inline ::std::string* CommonHeader::mutable_bodytype() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.CommonHeader.bodyType)
  return bodytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommonHeader::release_bodytype() {
  // @@protoc_insertion_point(field_release:DDRCommProto.CommonHeader.bodyType)
  
  return bodytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommonHeader::set_allocated_bodytype(::std::string* bodytype) {
  if (bodytype != NULL) {
    
  } else {
    
  }
  bodytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bodytype);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.CommonHeader.bodyType)
}

// repeated .DDRCommProto.CommonHeader.eFlowDir flowDirection = 2;
inline int CommonHeader::flowdirection_size() const {
  return flowdirection_.size();
}
inline void CommonHeader::clear_flowdirection() {
  flowdirection_.Clear();
}
inline ::DDRCommProto::CommonHeader_eFlowDir CommonHeader::flowdirection(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.flowDirection)
  return static_cast< ::DDRCommProto::CommonHeader_eFlowDir >(flowdirection_.Get(index));
}
inline void CommonHeader::set_flowdirection(int index, ::DDRCommProto::CommonHeader_eFlowDir value) {
  flowdirection_.Set(index, value);
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.flowDirection)
}
inline void CommonHeader::add_flowdirection(::DDRCommProto::CommonHeader_eFlowDir value) {
  flowdirection_.Add(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.flowDirection)
}
inline const ::google::protobuf::RepeatedField<int>&
CommonHeader::flowdirection() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.CommonHeader.flowDirection)
  return flowdirection_;
}
inline ::google::protobuf::RepeatedField<int>*
CommonHeader::mutable_flowdirection() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.CommonHeader.flowDirection)
  return &flowdirection_;
}

// int32 bOriginal = 3;
inline void CommonHeader::clear_boriginal() {
  boriginal_ = 0;
}
inline ::google::protobuf::int32 CommonHeader::boriginal() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.bOriginal)
  return boriginal_;
}
inline void CommonHeader::set_boriginal(::google::protobuf::int32 value) {
  
  boriginal_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.bOriginal)
}

// .DDRCommProto.CommonHeader.eSrcCondition srcCond = 4;
inline void CommonHeader::clear_srccond() {
  srccond_ = 0;
}
inline ::DDRCommProto::CommonHeader_eSrcCondition CommonHeader::srccond() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.srcCond)
  return static_cast< ::DDRCommProto::CommonHeader_eSrcCondition >(srccond_);
}
inline void CommonHeader::set_srccond(::DDRCommProto::CommonHeader_eSrcCondition value) {
  
  srccond_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.srcCond)
}

// .DDRCommProto.CommonHeader.eForwardingType forwardType = 5;
inline void CommonHeader::clear_forwardtype() {
  forwardtype_ = 0;
}
inline ::DDRCommProto::CommonHeader_eForwardingType CommonHeader::forwardtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.forwardType)
  return static_cast< ::DDRCommProto::CommonHeader_eForwardingType >(forwardtype_);
}
inline void CommonHeader::set_forwardtype(::DDRCommProto::CommonHeader_eForwardingType value) {
  
  forwardtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.forwardType)
}

// .DDRCommProto.CommonHeader.eSrcRecType recType = 6;
inline void CommonHeader::clear_rectype() {
  rectype_ = 0;
}
inline ::DDRCommProto::CommonHeader_eSrcRecType CommonHeader::rectype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.recType)
  return static_cast< ::DDRCommProto::CommonHeader_eSrcRecType >(rectype_);
}
inline void CommonHeader::set_rectype(::DDRCommProto::CommonHeader_eSrcRecType value) {
  
  rectype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.recType)
}

// repeated string prevRouteAddr = 7;
inline int CommonHeader::prevrouteaddr_size() const {
  return prevrouteaddr_.size();
}
inline void CommonHeader::clear_prevrouteaddr() {
  prevrouteaddr_.Clear();
}
inline const ::std::string& CommonHeader::prevrouteaddr(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.prevRouteAddr)
  return prevrouteaddr_.Get(index);
}
inline ::std::string* CommonHeader::mutable_prevrouteaddr(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.CommonHeader.prevRouteAddr)
  return prevrouteaddr_.Mutable(index);
}
inline void CommonHeader::set_prevrouteaddr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.prevRouteAddr)
  prevrouteaddr_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CommonHeader::set_prevrouteaddr(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.prevRouteAddr)
  prevrouteaddr_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CommonHeader::set_prevrouteaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  prevrouteaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.CommonHeader.prevRouteAddr)
}
inline void CommonHeader::set_prevrouteaddr(int index, const char* value, size_t size) {
  prevrouteaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.CommonHeader.prevRouteAddr)
}
inline ::std::string* CommonHeader::add_prevrouteaddr() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.CommonHeader.prevRouteAddr)
  return prevrouteaddr_.Add();
}
inline void CommonHeader::add_prevrouteaddr(const ::std::string& value) {
  prevrouteaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.prevRouteAddr)
}
#if LANG_CXX11
inline void CommonHeader::add_prevrouteaddr(::std::string&& value) {
  prevrouteaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.prevRouteAddr)
}
#endif
inline void CommonHeader::add_prevrouteaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  prevrouteaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.CommonHeader.prevRouteAddr)
}
inline void CommonHeader::add_prevrouteaddr(const char* value, size_t size) {
  prevrouteaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.CommonHeader.prevRouteAddr)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommonHeader::prevrouteaddr() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.CommonHeader.prevRouteAddr)
  return prevrouteaddr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommonHeader::mutable_prevrouteaddr() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.CommonHeader.prevRouteAddr)
  return &prevrouteaddr_;
}

// -------------------------------------------------------------------

// heartBeat

// string whatever = 1;
inline void heartBeat::clear_whatever() {
  whatever_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& heartBeat::whatever() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.heartBeat.whatever)
  return whatever_.GetNoArena();
}
inline void heartBeat::set_whatever(const ::std::string& value) {
  
  whatever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.heartBeat.whatever)
}
#if LANG_CXX11
inline void heartBeat::set_whatever(::std::string&& value) {
  
  whatever_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.heartBeat.whatever)
}
#endif
inline void heartBeat::set_whatever(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  whatever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.heartBeat.whatever)
}
inline void heartBeat::set_whatever(const char* value, size_t size) {
  
  whatever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.heartBeat.whatever)
}
inline ::std::string* heartBeat::mutable_whatever() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.heartBeat.whatever)
  return whatever_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* heartBeat::release_whatever() {
  // @@protoc_insertion_point(field_release:DDRCommProto.heartBeat.whatever)
  
  return whatever_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void heartBeat::set_allocated_whatever(::std::string* whatever) {
  if (whatever != NULL) {
    
  } else {
    
  }
  whatever_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), whatever);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.heartBeat.whatever)
}

// -------------------------------------------------------------------

// bcLSAddr_ServerInfo

// string name = 1;
inline void bcLSAddr_ServerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& bcLSAddr_ServerInfo::name() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.ServerInfo.name)
  return name_.GetNoArena();
}
inline void bcLSAddr_ServerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.ServerInfo.name)
}
#if LANG_CXX11
inline void bcLSAddr_ServerInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.bcLSAddr.ServerInfo.name)
}
#endif
inline void bcLSAddr_ServerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.bcLSAddr.ServerInfo.name)
}
inline void bcLSAddr_ServerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.bcLSAddr.ServerInfo.name)
}
inline ::std::string* bcLSAddr_ServerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.bcLSAddr.ServerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bcLSAddr_ServerInfo::release_name() {
  // @@protoc_insertion_point(field_release:DDRCommProto.bcLSAddr.ServerInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bcLSAddr_ServerInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.bcLSAddr.ServerInfo.name)
}

// repeated string ips = 2;
inline int bcLSAddr_ServerInfo::ips_size() const {
  return ips_.size();
}
inline void bcLSAddr_ServerInfo::clear_ips() {
  ips_.Clear();
}
inline const ::std::string& bcLSAddr_ServerInfo::ips(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.ServerInfo.ips)
  return ips_.Get(index);
}
inline ::std::string* bcLSAddr_ServerInfo::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.bcLSAddr.ServerInfo.ips)
  return ips_.Mutable(index);
}
inline void bcLSAddr_ServerInfo::set_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.ServerInfo.ips)
  ips_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void bcLSAddr_ServerInfo::set_ips(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.ServerInfo.ips)
  ips_.Mutable(index)->assign(std::move(value));
}
#endif
inline void bcLSAddr_ServerInfo::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.bcLSAddr.ServerInfo.ips)
}
inline void bcLSAddr_ServerInfo::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.bcLSAddr.ServerInfo.ips)
}
inline ::std::string* bcLSAddr_ServerInfo::add_ips() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.bcLSAddr.ServerInfo.ips)
  return ips_.Add();
}
inline void bcLSAddr_ServerInfo::add_ips(const ::std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.bcLSAddr.ServerInfo.ips)
}
#if LANG_CXX11
inline void bcLSAddr_ServerInfo::add_ips(::std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.bcLSAddr.ServerInfo.ips)
}
#endif
inline void bcLSAddr_ServerInfo::add_ips(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.bcLSAddr.ServerInfo.ips)
}
inline void bcLSAddr_ServerInfo::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.bcLSAddr.ServerInfo.ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
bcLSAddr_ServerInfo::ips() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.bcLSAddr.ServerInfo.ips)
  return ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
bcLSAddr_ServerInfo::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.bcLSAddr.ServerInfo.ips)
  return &ips_;
}

// int32 port = 3;
inline void bcLSAddr_ServerInfo::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 bcLSAddr_ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.ServerInfo.port)
  return port_;
}
inline void bcLSAddr_ServerInfo::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.ServerInfo.port)
}

// -------------------------------------------------------------------

// bcLSAddr

// .DDRCommProto.bcLSAddr.ServerInfo LSInfo = 1;
inline bool bcLSAddr::has_lsinfo() const {
  return this != internal_default_instance() && lsinfo_ != NULL;
}
inline void bcLSAddr::clear_lsinfo() {
  if (GetArenaNoVirtual() == NULL && lsinfo_ != NULL) {
    delete lsinfo_;
  }
  lsinfo_ = NULL;
}
inline const ::DDRCommProto::bcLSAddr_ServerInfo& bcLSAddr::_internal_lsinfo() const {
  return *lsinfo_;
}
inline const ::DDRCommProto::bcLSAddr_ServerInfo& bcLSAddr::lsinfo() const {
  const ::DDRCommProto::bcLSAddr_ServerInfo* p = lsinfo_;
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.LSInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::DDRCommProto::bcLSAddr_ServerInfo*>(
      &::DDRCommProto::_bcLSAddr_ServerInfo_default_instance_);
}
inline ::DDRCommProto::bcLSAddr_ServerInfo* bcLSAddr::release_lsinfo() {
  // @@protoc_insertion_point(field_release:DDRCommProto.bcLSAddr.LSInfo)
  
  ::DDRCommProto::bcLSAddr_ServerInfo* temp = lsinfo_;
  lsinfo_ = NULL;
  return temp;
}
inline ::DDRCommProto::bcLSAddr_ServerInfo* bcLSAddr::mutable_lsinfo() {
  
  if (lsinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::DDRCommProto::bcLSAddr_ServerInfo>(GetArenaNoVirtual());
    lsinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DDRCommProto.bcLSAddr.LSInfo)
  return lsinfo_;
}
inline void bcLSAddr::set_allocated_lsinfo(::DDRCommProto::bcLSAddr_ServerInfo* lsinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lsinfo_;
  }
  if (lsinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lsinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lsinfo, submessage_arena);
    }
    
  } else {
    
  }
  lsinfo_ = lsinfo;
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.bcLSAddr.LSInfo)
}

// -------------------------------------------------------------------

// reqLogin_msgAVStreamReq

// int32 avType = 1;
inline void reqLogin_msgAVStreamReq::clear_avtype() {
  avtype_ = 0;
}
inline ::google::protobuf::int32 reqLogin_msgAVStreamReq::avtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.msgAVStreamReq.avType)
  return avtype_;
}
inline void reqLogin_msgAVStreamReq::set_avtype(::google::protobuf::int32 value) {
  
  avtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.msgAVStreamReq.avType)
}

// string chName = 2;
inline void reqLogin_msgAVStreamReq::clear_chname() {
  chname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin_msgAVStreamReq::chname() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.msgAVStreamReq.chName)
  return chname_.GetNoArena();
}
inline void reqLogin_msgAVStreamReq::set_chname(const ::std::string& value) {
  
  chname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
#if LANG_CXX11
inline void reqLogin_msgAVStreamReq::set_chname(::std::string&& value) {
  
  chname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
#endif
inline void reqLogin_msgAVStreamReq::set_chname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
inline void reqLogin_msgAVStreamReq::set_chname(const char* value, size_t size) {
  
  chname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
inline ::std::string* reqLogin_msgAVStreamReq::mutable_chname() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.msgAVStreamReq.chName)
  return chname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin_msgAVStreamReq::release_chname() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.msgAVStreamReq.chName)
  
  return chname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin_msgAVStreamReq::set_allocated_chname(::std::string* chname) {
  if (chname != NULL) {
    
  } else {
    
  }
  chname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chname);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}

// int32 bandwidthReq = 3;
inline void reqLogin_msgAVStreamReq::clear_bandwidthreq() {
  bandwidthreq_ = 0;
}
inline ::google::protobuf::int32 reqLogin_msgAVStreamReq::bandwidthreq() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.msgAVStreamReq.bandwidthReq)
  return bandwidthreq_;
}
inline void reqLogin_msgAVStreamReq::set_bandwidthreq(::google::protobuf::int32 value) {
  
  bandwidthreq_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.msgAVStreamReq.bandwidthReq)
}

// -------------------------------------------------------------------

// reqLogin

// .DDRCommProto.reqLogin.eCltType type = 1;
inline void reqLogin::clear_type() {
  type_ = 0;
}
inline ::DDRCommProto::reqLogin_eCltType reqLogin::type() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.type)
  return static_cast< ::DDRCommProto::reqLogin_eCltType >(type_);
}
inline void reqLogin::set_type(::DDRCommProto::reqLogin_eCltType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.type)
}

// string username = 2;
inline void reqLogin::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin::username() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.username)
  return username_.GetNoArena();
}
inline void reqLogin::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.username)
}
#if LANG_CXX11
inline void reqLogin::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.username)
}
#endif
inline void reqLogin::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.username)
}
inline void reqLogin::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.username)
}
inline ::std::string* reqLogin::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin::release_username() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.username)
}

// string robotID = 3;
inline void reqLogin::clear_robotid() {
  robotid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin::robotid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.robotID)
  return robotid_.GetNoArena();
}
inline void reqLogin::set_robotid(const ::std::string& value) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.robotID)
}
#if LANG_CXX11
inline void reqLogin::set_robotid(::std::string&& value) {
  
  robotid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.robotID)
}
#endif
inline void reqLogin::set_robotid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.robotID)
}
inline void reqLogin::set_robotid(const char* value, size_t size) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.robotID)
}
inline ::std::string* reqLogin::mutable_robotid() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.robotID)
  return robotid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin::release_robotid() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.robotID)
  
  return robotid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin::set_allocated_robotid(::std::string* robotid) {
  if (robotid != NULL) {
    
  } else {
    
  }
  robotid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotid);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.robotID)
}

// string robotPWD = 4;
inline void reqLogin::clear_robotpwd() {
  robotpwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin::robotpwd() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.robotPWD)
  return robotpwd_.GetNoArena();
}
inline void reqLogin::set_robotpwd(const ::std::string& value) {
  
  robotpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.robotPWD)
}
#if LANG_CXX11
inline void reqLogin::set_robotpwd(::std::string&& value) {
  
  robotpwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.robotPWD)
}
#endif
inline void reqLogin::set_robotpwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.robotPWD)
}
inline void reqLogin::set_robotpwd(const char* value, size_t size) {
  
  robotpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.robotPWD)
}
inline ::std::string* reqLogin::mutable_robotpwd() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.robotPWD)
  return robotpwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin::release_robotpwd() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.robotPWD)
  
  return robotpwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin::set_allocated_robotpwd(::std::string* robotpwd) {
  if (robotpwd != NULL) {
    
  } else {
    
  }
  robotpwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotpwd);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.robotPWD)
}

// int32 cltOpLv = 5;
inline void reqLogin::clear_cltoplv() {
  cltoplv_ = 0;
}
inline ::google::protobuf::int32 reqLogin::cltoplv() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.cltOpLv)
  return cltoplv_;
}
inline void reqLogin::set_cltoplv(::google::protobuf::int32 value) {
  
  cltoplv_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.cltOpLv)
}

// int32 UID = 6;
inline void reqLogin::clear_uid() {
  uid_ = 0;
}
inline ::google::protobuf::int32 reqLogin::uid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.UID)
  return uid_;
}
inline void reqLogin::set_uid(::google::protobuf::int32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.UID)
}

// repeated .DDRCommProto.reqLogin.msgAVStreamReq avStreamReq = 7;
inline int reqLogin::avstreamreq_size() const {
  return avstreamreq_.size();
}
inline void reqLogin::clear_avstreamreq() {
  avstreamreq_.Clear();
}
inline ::DDRCommProto::reqLogin_msgAVStreamReq* reqLogin::mutable_avstreamreq(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >*
reqLogin::mutable_avstreamreq() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.reqLogin.avStreamReq)
  return &avstreamreq_;
}
inline const ::DDRCommProto::reqLogin_msgAVStreamReq& reqLogin::avstreamreq(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_.Get(index);
}
inline ::DDRCommProto::reqLogin_msgAVStreamReq* reqLogin::add_avstreamreq() {
  // @@protoc_insertion_point(field_add:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >&
reqLogin::avstreamreq() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_;
}

// -------------------------------------------------------------------

// respLogin

// .DDRCommProto.respLogin.eLoginRetCode retcode = 1;
inline void respLogin::clear_retcode() {
  retcode_ = 0;
}
inline ::DDRCommProto::respLogin_eLoginRetCode respLogin::retcode() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respLogin.retcode)
  return static_cast< ::DDRCommProto::respLogin_eLoginRetCode >(retcode_);
}
inline void respLogin::set_retcode(::DDRCommProto::respLogin_eLoginRetCode value) {
  
  retcode_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respLogin.retcode)
}

// .DDRCommProto.respLogin.eCltType yourRole = 2;
inline void respLogin::clear_yourrole() {
  yourrole_ = 0;
}
inline ::DDRCommProto::respLogin_eCltType respLogin::yourrole() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respLogin.yourRole)
  return static_cast< ::DDRCommProto::respLogin_eCltType >(yourrole_);
}
inline void respLogin::set_yourrole(::DDRCommProto::respLogin_eCltType value) {
  
  yourrole_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respLogin.yourRole)
}

// int32 UID = 3;
inline void respLogin::clear_uid() {
  uid_ = 0;
}
inline ::google::protobuf::int32 respLogin::uid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respLogin.UID)
  return uid_;
}
inline void respLogin::set_uid(::google::protobuf::int32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respLogin.UID)
}

// -------------------------------------------------------------------

// notifyTerminalAccess

// int32 bRRConnected2RS = 1;
inline void notifyTerminalAccess::clear_brrconnected2rs() {
  brrconnected2rs_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::brrconnected2rs() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.bRRConnected2RS)
  return brrconnected2rs_;
}
inline void notifyTerminalAccess::set_brrconnected2rs(::google::protobuf::int32 value) {
  
  brrconnected2rs_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.bRRConnected2RS)
}

// int32 bOp = 2;
inline void notifyTerminalAccess::clear_bop() {
  bop_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::bop() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.bOp)
  return bop_;
}
inline void notifyTerminalAccess::set_bop(::google::protobuf::int32 value) {
  
  bop_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.bOp)
}

// int32 nMonitors = 3;
inline void notifyTerminalAccess::clear_nmonitors() {
  nmonitors_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::nmonitors() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.nMonitors)
  return nmonitors_;
}
inline void notifyTerminalAccess::set_nmonitors(::google::protobuf::int32 value) {
  
  nmonitors_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nMonitors)
}

// int32 nClients = 4;
inline void notifyTerminalAccess::clear_nclients() {
  nclients_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::nclients() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.nClients)
  return nclients_;
}
inline void notifyTerminalAccess::set_nclients(::google::protobuf::int32 value) {
  
  nclients_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nClients)
}

// repeated string nameLSMs = 5;
inline int notifyTerminalAccess::namelsms_size() const {
  return namelsms_.size();
}
inline void notifyTerminalAccess::clear_namelsms() {
  namelsms_.Clear();
}
inline const ::std::string& notifyTerminalAccess::namelsms(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_.Get(index);
}
inline ::std::string* notifyTerminalAccess::mutable_namelsms(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_.Mutable(index);
}
inline void notifyTerminalAccess::set_namelsms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nameLSMs)
  namelsms_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void notifyTerminalAccess::set_namelsms(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nameLSMs)
  namelsms_.Mutable(index)->assign(std::move(value));
}
#endif
inline void notifyTerminalAccess::set_namelsms(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  namelsms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline void notifyTerminalAccess::set_namelsms(int index, const char* value, size_t size) {
  namelsms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline ::std::string* notifyTerminalAccess::add_namelsms() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_.Add();
}
inline void notifyTerminalAccess::add_namelsms(const ::std::string& value) {
  namelsms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
#if LANG_CXX11
inline void notifyTerminalAccess::add_namelsms(::std::string&& value) {
  namelsms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
#endif
inline void notifyTerminalAccess::add_namelsms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  namelsms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline void notifyTerminalAccess::add_namelsms(const char* value, size_t size) {
  namelsms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
notifyTerminalAccess::namelsms() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
notifyTerminalAccess::mutable_namelsms() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return &namelsms_;
}

// -------------------------------------------------------------------

// notifySerAccess

// int32 nMonitors = 1;
inline void notifySerAccess::clear_nmonitors() {
  nmonitors_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::nmonitors() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.nMonitors)
  return nmonitors_;
}
inline void notifySerAccess::set_nmonitors(::google::protobuf::int32 value) {
  
  nmonitors_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.nMonitors)
}

// int32 mTopOpLv = 2;
inline void notifySerAccess::clear_mtopoplv() {
  mtopoplv_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::mtopoplv() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.mTopOpLv)
  return mtopoplv_;
}
inline void notifySerAccess::set_mtopoplv(::google::protobuf::int32 value) {
  
  mtopoplv_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.mTopOpLv)
}

// int32 mTopOpTime = 3;
inline void notifySerAccess::clear_mtopoptime() {
  mtopoptime_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::mtopoptime() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.mTopOpTime)
  return mtopoptime_;
}
inline void notifySerAccess::set_mtopoptime(::google::protobuf::int32 value) {
  
  mtopoptime_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.mTopOpTime)
}

// int32 nClients = 4;
inline void notifySerAccess::clear_nclients() {
  nclients_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::nclients() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.nClients)
  return nclients_;
}
inline void notifySerAccess::set_nclients(::google::protobuf::int32 value) {
  
  nclients_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.nClients)
}

// int32 cTopOpLv = 5;
inline void notifySerAccess::clear_ctopoplv() {
  ctopoplv_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::ctopoplv() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.cTopOpLv)
  return ctopoplv_;
}
inline void notifySerAccess::set_ctopoplv(::google::protobuf::int32 value) {
  
  ctopoplv_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.cTopOpLv)
}

// int64 cTopOpTime = 6;
inline void notifySerAccess::clear_ctopoptime() {
  ctopoptime_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 notifySerAccess::ctopoptime() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.cTopOpTime)
  return ctopoptime_;
}
inline void notifySerAccess::set_ctopoptime(::google::protobuf::int64 value) {
  
  ctopoptime_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.cTopOpTime)
}

// repeated string namesLSM = 7;
inline int notifySerAccess::nameslsm_size() const {
  return nameslsm_.size();
}
inline void notifySerAccess::clear_nameslsm() {
  nameslsm_.Clear();
}
inline const ::std::string& notifySerAccess::nameslsm(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_.Get(index);
}
inline ::std::string* notifySerAccess::mutable_nameslsm(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_.Mutable(index);
}
inline void notifySerAccess::set_nameslsm(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.namesLSM)
  nameslsm_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void notifySerAccess::set_nameslsm(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.namesLSM)
  nameslsm_.Mutable(index)->assign(std::move(value));
}
#endif
inline void notifySerAccess::set_nameslsm(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nameslsm_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifySerAccess.namesLSM)
}
inline void notifySerAccess::set_nameslsm(int index, const char* value, size_t size) {
  nameslsm_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifySerAccess.namesLSM)
}
inline ::std::string* notifySerAccess::add_nameslsm() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_.Add();
}
inline void notifySerAccess::add_nameslsm(const ::std::string& value) {
  nameslsm_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.notifySerAccess.namesLSM)
}
#if LANG_CXX11
inline void notifySerAccess::add_nameslsm(::std::string&& value) {
  nameslsm_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.notifySerAccess.namesLSM)
}
#endif
inline void notifySerAccess::add_nameslsm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nameslsm_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.notifySerAccess.namesLSM)
}
inline void notifySerAccess::add_nameslsm(const char* value, size_t size) {
  nameslsm_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.notifySerAccess.namesLSM)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
notifySerAccess::nameslsm() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
notifySerAccess::mutable_nameslsm() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.notifySerAccess.namesLSM)
  return &nameslsm_;
}

// -------------------------------------------------------------------

// notifyAVStream_fullChannelInfo

// int32 devType = 1;
inline void notifyAVStream_fullChannelInfo::clear_devtype() {
  devtype_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::devtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.devType)
  return devtype_;
}
inline void notifyAVStream_fullChannelInfo::set_devtype(::google::protobuf::int32 value) {
  
  devtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.devType)
}

// int32 dataType = 2;
inline void notifyAVStream_fullChannelInfo::clear_datatype() {
  datatype_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::datatype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.dataType)
  return datatype_;
}
inline void notifyAVStream_fullChannelInfo::set_datatype(::google::protobuf::int32 value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.dataType)
}

// string localResAccStr = 3;
inline void notifyAVStream_fullChannelInfo::clear_localresaccstr() {
  localresaccstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAVStream_fullChannelInfo::localresaccstr() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
  return localresaccstr_.GetNoArena();
}
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(const ::std::string& value) {
  
  localresaccstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
#if LANG_CXX11
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(::std::string&& value) {
  
  localresaccstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
#endif
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  localresaccstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(const char* value, size_t size) {
  
  localresaccstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
inline ::std::string* notifyAVStream_fullChannelInfo::mutable_localresaccstr() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
  return localresaccstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAVStream_fullChannelInfo::release_localresaccstr() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
  
  return localresaccstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAVStream_fullChannelInfo::set_allocated_localresaccstr(::std::string* localresaccstr) {
  if (localresaccstr != NULL) {
    
  } else {
    
  }
  localresaccstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), localresaccstr);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}

// string channelDescription = 4;
inline void notifyAVStream_fullChannelInfo::clear_channeldescription() {
  channeldescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAVStream_fullChannelInfo::channeldescription() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
  return channeldescription_.GetNoArena();
}
inline void notifyAVStream_fullChannelInfo::set_channeldescription(const ::std::string& value) {
  
  channeldescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
#if LANG_CXX11
inline void notifyAVStream_fullChannelInfo::set_channeldescription(::std::string&& value) {
  
  channeldescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
#endif
inline void notifyAVStream_fullChannelInfo::set_channeldescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channeldescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
inline void notifyAVStream_fullChannelInfo::set_channeldescription(const char* value, size_t size) {
  
  channeldescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
inline ::std::string* notifyAVStream_fullChannelInfo::mutable_channeldescription() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
  return channeldescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAVStream_fullChannelInfo::release_channeldescription() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
  
  return channeldescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAVStream_fullChannelInfo::set_allocated_channeldescription(::std::string* channeldescription) {
  if (channeldescription != NULL) {
    
  } else {
    
  }
  channeldescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channeldescription);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}

// int32 bwReq = 5;
inline void notifyAVStream_fullChannelInfo::clear_bwreq() {
  bwreq_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::bwreq() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.bwReq)
  return bwreq_;
}
inline void notifyAVStream_fullChannelInfo::set_bwreq(::google::protobuf::int32 value) {
  
  bwreq_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.bwReq)
}

// int64 remoteIP = 6;
inline void notifyAVStream_fullChannelInfo::clear_remoteip() {
  remoteip_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 notifyAVStream_fullChannelInfo::remoteip() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.remoteIP)
  return remoteip_;
}
inline void notifyAVStream_fullChannelInfo::set_remoteip(::google::protobuf::int64 value) {
  
  remoteip_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.remoteIP)
}

// int32 remotePort = 7;
inline void notifyAVStream_fullChannelInfo::clear_remoteport() {
  remoteport_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::remoteport() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.remotePort)
  return remoteport_;
}
inline void notifyAVStream_fullChannelInfo::set_remoteport(::google::protobuf::int32 value) {
  
  remoteport_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.remotePort)
}

// string remotePass = 8;
inline void notifyAVStream_fullChannelInfo::clear_remotepass() {
  remotepass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAVStream_fullChannelInfo::remotepass() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
  return remotepass_.GetNoArena();
}
inline void notifyAVStream_fullChannelInfo::set_remotepass(const ::std::string& value) {
  
  remotepass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
#if LANG_CXX11
inline void notifyAVStream_fullChannelInfo::set_remotepass(::std::string&& value) {
  
  remotepass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
#endif
inline void notifyAVStream_fullChannelInfo::set_remotepass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remotepass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
inline void notifyAVStream_fullChannelInfo::set_remotepass(const char* value, size_t size) {
  
  remotepass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
inline ::std::string* notifyAVStream_fullChannelInfo::mutable_remotepass() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
  return remotepass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAVStream_fullChannelInfo::release_remotepass() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
  
  return remotepass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAVStream_fullChannelInfo::set_allocated_remotepass(::std::string* remotepass) {
  if (remotepass != NULL) {
    
  } else {
    
  }
  remotepass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remotepass);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}

// -------------------------------------------------------------------

// notifyAVStream

// .DDRCommProto.notifyAVStream.fullChannelInfo reservedChannel = 1;
inline bool notifyAVStream::has_reservedchannel() const {
  return this != internal_default_instance() && reservedchannel_ != NULL;
}
inline void notifyAVStream::clear_reservedchannel() {
  if (GetArenaNoVirtual() == NULL && reservedchannel_ != NULL) {
    delete reservedchannel_;
  }
  reservedchannel_ = NULL;
}
inline const ::DDRCommProto::notifyAVStream_fullChannelInfo& notifyAVStream::_internal_reservedchannel() const {
  return *reservedchannel_;
}
inline const ::DDRCommProto::notifyAVStream_fullChannelInfo& notifyAVStream::reservedchannel() const {
  const ::DDRCommProto::notifyAVStream_fullChannelInfo* p = reservedchannel_;
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.reservedChannel)
  return p != NULL ? *p : *reinterpret_cast<const ::DDRCommProto::notifyAVStream_fullChannelInfo*>(
      &::DDRCommProto::_notifyAVStream_fullChannelInfo_default_instance_);
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::release_reservedchannel() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.reservedChannel)
  
  ::DDRCommProto::notifyAVStream_fullChannelInfo* temp = reservedchannel_;
  reservedchannel_ = NULL;
  return temp;
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::mutable_reservedchannel() {
  
  if (reservedchannel_ == NULL) {
    auto* p = CreateMaybeMessage<::DDRCommProto::notifyAVStream_fullChannelInfo>(GetArenaNoVirtual());
    reservedchannel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.reservedChannel)
  return reservedchannel_;
}
inline void notifyAVStream::set_allocated_reservedchannel(::DDRCommProto::notifyAVStream_fullChannelInfo* reservedchannel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reservedchannel_;
  }
  if (reservedchannel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reservedchannel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reservedchannel, submessage_arena);
    }
    
  } else {
    
  }
  reservedchannel_ = reservedchannel;
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.reservedChannel)
}

// repeated .DDRCommProto.notifyAVStream.fullChannelInfo robotMonitorChannels = 2;
inline int notifyAVStream::robotmonitorchannels_size() const {
  return robotmonitorchannels_.size();
}
inline void notifyAVStream::clear_robotmonitorchannels() {
  robotmonitorchannels_.Clear();
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::mutable_robotmonitorchannels(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >*
notifyAVStream::mutable_robotmonitorchannels() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return &robotmonitorchannels_;
}
inline const ::DDRCommProto::notifyAVStream_fullChannelInfo& notifyAVStream::robotmonitorchannels(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_.Get(index);
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::add_robotmonitorchannels() {
  // @@protoc_insertion_point(field_add:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >&
notifyAVStream::robotmonitorchannels() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_;
}

// -------------------------------------------------------------------

// reqTalk

// .DDRCommProto.reqTalk.eCallerType callerType = 1;
inline void reqTalk::clear_callertype() {
  callertype_ = 0;
}
inline ::DDRCommProto::reqTalk_eCallerType reqTalk::callertype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.callerType)
  return static_cast< ::DDRCommProto::reqTalk_eCallerType >(callertype_);
}
inline void reqTalk::set_callertype(::DDRCommProto::reqTalk_eCallerType value) {
  
  callertype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.callerType)
}

// int32 talkID = 2;
inline void reqTalk::clear_talkid() {
  talkid_ = 0;
}
inline ::google::protobuf::int32 reqTalk::talkid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.talkID)
  return talkid_;
}
inline void reqTalk::set_talkid(::google::protobuf::int32 value) {
  
  talkid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.talkID)
}

// int32 avType = 3;
inline void reqTalk::clear_avtype() {
  avtype_ = 0;
}
inline ::google::protobuf::int32 reqTalk::avtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.avType)
  return avtype_;
}
inline void reqTalk::set_avtype(::google::protobuf::int32 value) {
  
  avtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.avType)
}

// repeated string localTalkAddr = 4;
inline int reqTalk::localtalkaddr_size() const {
  return localtalkaddr_.size();
}
inline void reqTalk::clear_localtalkaddr() {
  localtalkaddr_.Clear();
}
inline const ::std::string& reqTalk::localtalkaddr(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.localTalkAddr)
  return localtalkaddr_.Get(index);
}
inline ::std::string* reqTalk::mutable_localtalkaddr(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqTalk.localTalkAddr)
  return localtalkaddr_.Mutable(index);
}
inline void reqTalk::set_localtalkaddr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.localTalkAddr)
  localtalkaddr_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void reqTalk::set_localtalkaddr(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.localTalkAddr)
  localtalkaddr_.Mutable(index)->assign(std::move(value));
}
#endif
inline void reqTalk::set_localtalkaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  localtalkaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqTalk.localTalkAddr)
}
inline void reqTalk::set_localtalkaddr(int index, const char* value, size_t size) {
  localtalkaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqTalk.localTalkAddr)
}
inline ::std::string* reqTalk::add_localtalkaddr() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.reqTalk.localTalkAddr)
  return localtalkaddr_.Add();
}
inline void reqTalk::add_localtalkaddr(const ::std::string& value) {
  localtalkaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.reqTalk.localTalkAddr)
}
#if LANG_CXX11
inline void reqTalk::add_localtalkaddr(::std::string&& value) {
  localtalkaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.reqTalk.localTalkAddr)
}
#endif
inline void reqTalk::add_localtalkaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  localtalkaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.reqTalk.localTalkAddr)
}
inline void reqTalk::add_localtalkaddr(const char* value, size_t size) {
  localtalkaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.reqTalk.localTalkAddr)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
reqTalk::localtalkaddr() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.reqTalk.localTalkAddr)
  return localtalkaddr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
reqTalk::mutable_localtalkaddr() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.reqTalk.localTalkAddr)
  return &localtalkaddr_;
}

// -------------------------------------------------------------------

// respTalk

// .DDRCommProto.respTalk.eReceiverType receiverType = 1;
inline void respTalk::clear_receivertype() {
  receivertype_ = 0;
}
inline ::DDRCommProto::respTalk_eReceiverType respTalk::receivertype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.receiverType)
  return static_cast< ::DDRCommProto::respTalk_eReceiverType >(receivertype_);
}
inline void respTalk::set_receivertype(::DDRCommProto::respTalk_eReceiverType value) {
  
  receivertype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.receiverType)
}

// int32 talkID = 2;
inline void respTalk::clear_talkid() {
  talkid_ = 0;
}
inline ::google::protobuf::int32 respTalk::talkid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.talkID)
  return talkid_;
}
inline void respTalk::set_talkid(::google::protobuf::int32 value) {
  
  talkid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.talkID)
}

// int32 avType = 3;
inline void respTalk::clear_avtype() {
  avtype_ = 0;
}
inline ::google::protobuf::int32 respTalk::avtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.avType)
  return avtype_;
}
inline void respTalk::set_avtype(::google::protobuf::int32 value) {
  
  avtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.avType)
}

// -------------------------------------------------------------------

// reqTalkHB

// int32 callerTalkID = 1;
inline void reqTalkHB::clear_callertalkid() {
  callertalkid_ = 0;
}
inline ::google::protobuf::int32 reqTalkHB::callertalkid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalkHB.callerTalkID)
  return callertalkid_;
}
inline void reqTalkHB::set_callertalkid(::google::protobuf::int32 value) {
  
  callertalkid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalkHB.callerTalkID)
}

// int32 receiverTalkID = 2;
inline void reqTalkHB::clear_receivertalkid() {
  receivertalkid_ = 0;
}
inline ::google::protobuf::int32 reqTalkHB::receivertalkid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalkHB.receiverTalkID)
  return receivertalkid_;
}
inline void reqTalkHB::set_receivertalkid(::google::protobuf::int32 value) {
  
  receivertalkid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalkHB.receiverTalkID)
}

// -------------------------------------------------------------------

// reqCmd

// int64 cmdID = 1;
inline void reqCmd::clear_cmdid() {
  cmdid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 reqCmd::cmdid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqCmd.cmdID)
  return cmdid_;
}
inline void reqCmd::set_cmdid(::google::protobuf::int64 value) {
  
  cmdid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqCmd.cmdID)
}

// string cmdMsg = 2;
inline void reqCmd::clear_cmdmsg() {
  cmdmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqCmd::cmdmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqCmd.cmdMsg)
  return cmdmsg_.GetNoArena();
}
inline void reqCmd::set_cmdmsg(const ::std::string& value) {
  
  cmdmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqCmd.cmdMsg)
}
#if LANG_CXX11
inline void reqCmd::set_cmdmsg(::std::string&& value) {
  
  cmdmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqCmd.cmdMsg)
}
#endif
inline void reqCmd::set_cmdmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cmdmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqCmd.cmdMsg)
}
inline void reqCmd::set_cmdmsg(const char* value, size_t size) {
  
  cmdmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqCmd.cmdMsg)
}
inline ::std::string* reqCmd::mutable_cmdmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqCmd.cmdMsg)
  return cmdmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqCmd::release_cmdmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqCmd.cmdMsg)
  
  return cmdmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqCmd::set_allocated_cmdmsg(::std::string* cmdmsg) {
  if (cmdmsg != NULL) {
    
  } else {
    
  }
  cmdmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmdmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqCmd.cmdMsg)
}

// -------------------------------------------------------------------

// respCmd

// int64 cmdID = 1;
inline void respCmd::clear_cmdid() {
  cmdid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 respCmd::cmdid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respCmd.cmdID)
  return cmdid_;
}
inline void respCmd::set_cmdid(::google::protobuf::int64 value) {
  
  cmdid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respCmd.cmdID)
}

// string respMsg = 2;
inline void respCmd::clear_respmsg() {
  respmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& respCmd::respmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respCmd.respMsg)
  return respmsg_.GetNoArena();
}
inline void respCmd::set_respmsg(const ::std::string& value) {
  
  respmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.respCmd.respMsg)
}
#if LANG_CXX11
inline void respCmd::set_respmsg(::std::string&& value) {
  
  respmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.respCmd.respMsg)
}
#endif
inline void respCmd::set_respmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  respmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respCmd.respMsg)
}
inline void respCmd::set_respmsg(const char* value, size_t size) {
  
  respmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respCmd.respMsg)
}
inline ::std::string* respCmd::mutable_respmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respCmd.respMsg)
  return respmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* respCmd::release_respmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.respCmd.respMsg)
  
  return respmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void respCmd::set_allocated_respmsg(::std::string* respmsg) {
  if (respmsg != NULL) {
    
  } else {
    
  }
  respmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), respmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.respCmd.respMsg)
}

// -------------------------------------------------------------------

// reqFile

// string tarLSMName = 1;
inline void reqFile::clear_tarlsmname() {
  tarlsmname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqFile::tarlsmname() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFile.tarLSMName)
  return tarlsmname_.GetNoArena();
}
inline void reqFile::set_tarlsmname(const ::std::string& value) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFile.tarLSMName)
}
#if LANG_CXX11
inline void reqFile::set_tarlsmname(::std::string&& value) {
  
  tarlsmname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqFile.tarLSMName)
}
#endif
inline void reqFile::set_tarlsmname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqFile.tarLSMName)
}
inline void reqFile::set_tarlsmname(const char* value, size_t size) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqFile.tarLSMName)
}
inline ::std::string* reqFile::mutable_tarlsmname() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqFile.tarLSMName)
  return tarlsmname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqFile::release_tarlsmname() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqFile.tarLSMName)
  
  return tarlsmname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqFile::set_allocated_tarlsmname(::std::string* tarlsmname) {
  if (tarlsmname != NULL) {
    
  } else {
    
  }
  tarlsmname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tarlsmname);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqFile.tarLSMName)
}

// .DDRCommProto.reqFile.eFileTypes fileType = 2;
inline void reqFile::clear_filetype() {
  filetype_ = 0;
}
inline ::DDRCommProto::reqFile_eFileTypes reqFile::filetype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFile.fileType)
  return static_cast< ::DDRCommProto::reqFile_eFileTypes >(filetype_);
}
inline void reqFile::set_filetype(::DDRCommProto::reqFile_eFileTypes value) {
  
  filetype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFile.fileType)
}

// repeated string fileNames = 3;
inline int reqFile::filenames_size() const {
  return filenames_.size();
}
inline void reqFile::clear_filenames() {
  filenames_.Clear();
}
inline const ::std::string& reqFile::filenames(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFile.fileNames)
  return filenames_.Get(index);
}
inline ::std::string* reqFile::mutable_filenames(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqFile.fileNames)
  return filenames_.Mutable(index);
}
inline void reqFile::set_filenames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFile.fileNames)
  filenames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void reqFile::set_filenames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFile.fileNames)
  filenames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void reqFile::set_filenames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqFile.fileNames)
}
inline void reqFile::set_filenames(int index, const char* value, size_t size) {
  filenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqFile.fileNames)
}
inline ::std::string* reqFile::add_filenames() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.reqFile.fileNames)
  return filenames_.Add();
}
inline void reqFile::add_filenames(const ::std::string& value) {
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.reqFile.fileNames)
}
#if LANG_CXX11
inline void reqFile::add_filenames(::std::string&& value) {
  filenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.reqFile.fileNames)
}
#endif
inline void reqFile::add_filenames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.reqFile.fileNames)
}
inline void reqFile::add_filenames(const char* value, size_t size) {
  filenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.reqFile.fileNames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
reqFile::filenames() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.reqFile.fileNames)
  return filenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
reqFile::mutable_filenames() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.reqFile.fileNames)
  return &filenames_;
}

// -------------------------------------------------------------------

// respFile

// string tarLSMName = 1;
inline void respFile::clear_tarlsmname() {
  tarlsmname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& respFile::tarlsmname() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFile.tarLSMName)
  return tarlsmname_.GetNoArena();
}
inline void respFile::set_tarlsmname(const ::std::string& value) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.tarLSMName)
}
#if LANG_CXX11
inline void respFile::set_tarlsmname(::std::string&& value) {
  
  tarlsmname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.respFile.tarLSMName)
}
#endif
inline void respFile::set_tarlsmname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFile.tarLSMName)
}
inline void respFile::set_tarlsmname(const char* value, size_t size) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFile.tarLSMName)
}
inline ::std::string* respFile::mutable_tarlsmname() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFile.tarLSMName)
  return tarlsmname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* respFile::release_tarlsmname() {
  // @@protoc_insertion_point(field_release:DDRCommProto.respFile.tarLSMName)
  
  return tarlsmname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void respFile::set_allocated_tarlsmname(::std::string* tarlsmname) {
  if (tarlsmname != NULL) {
    
  } else {
    
  }
  tarlsmname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tarlsmname);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.respFile.tarLSMName)
}

// .DDRCommProto.respFile.eFileTypes fileType = 2;
inline void respFile::clear_filetype() {
  filetype_ = 0;
}
inline ::DDRCommProto::respFile_eFileTypes respFile::filetype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFile.fileType)
  return static_cast< ::DDRCommProto::respFile_eFileTypes >(filetype_);
}
inline void respFile::set_filetype(::DDRCommProto::respFile_eFileTypes value) {
  
  filetype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.fileType)
}

// repeated string fileNames = 3;
inline int respFile::filenames_size() const {
  return filenames_.size();
}
inline void respFile::clear_filenames() {
  filenames_.Clear();
}
inline const ::std::string& respFile::filenames(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFile.fileNames)
  return filenames_.Get(index);
}
inline ::std::string* respFile::mutable_filenames(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFile.fileNames)
  return filenames_.Mutable(index);
}
inline void respFile::set_filenames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.fileNames)
  filenames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void respFile::set_filenames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.fileNames)
  filenames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void respFile::set_filenames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFile.fileNames)
}
inline void respFile::set_filenames(int index, const char* value, size_t size) {
  filenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFile.fileNames)
}
inline ::std::string* respFile::add_filenames() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.respFile.fileNames)
  return filenames_.Add();
}
inline void respFile::add_filenames(const ::std::string& value) {
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.respFile.fileNames)
}
#if LANG_CXX11
inline void respFile::add_filenames(::std::string&& value) {
  filenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.respFile.fileNames)
}
#endif
inline void respFile::add_filenames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.respFile.fileNames)
}
inline void respFile::add_filenames(const char* value, size_t size) {
  filenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.respFile.fileNames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
respFile::filenames() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.respFile.fileNames)
  return filenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
respFile::mutable_filenames() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.respFile.fileNames)
  return &filenames_;
}

// repeated string fileContents = 4;
inline int respFile::filecontents_size() const {
  return filecontents_.size();
}
inline void respFile::clear_filecontents() {
  filecontents_.Clear();
}
inline const ::std::string& respFile::filecontents(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFile.fileContents)
  return filecontents_.Get(index);
}
inline ::std::string* respFile::mutable_filecontents(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFile.fileContents)
  return filecontents_.Mutable(index);
}
inline void respFile::set_filecontents(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.fileContents)
  filecontents_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void respFile::set_filecontents(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.fileContents)
  filecontents_.Mutable(index)->assign(std::move(value));
}
#endif
inline void respFile::set_filecontents(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filecontents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFile.fileContents)
}
inline void respFile::set_filecontents(int index, const char* value, size_t size) {
  filecontents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFile.fileContents)
}
inline ::std::string* respFile::add_filecontents() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.respFile.fileContents)
  return filecontents_.Add();
}
inline void respFile::add_filecontents(const ::std::string& value) {
  filecontents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.respFile.fileContents)
}
#if LANG_CXX11
inline void respFile::add_filecontents(::std::string&& value) {
  filecontents_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.respFile.fileContents)
}
#endif
inline void respFile::add_filecontents(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filecontents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.respFile.fileContents)
}
inline void respFile::add_filecontents(const char* value, size_t size) {
  filecontents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.respFile.fileContents)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
respFile::filecontents() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.respFile.fileContents)
  return filecontents_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
respFile::mutable_filecontents() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.respFile.fileContents)
  return &filecontents_;
}

// -------------------------------------------------------------------

// reqFileAddr

// string tarLSMName = 1;
inline void reqFileAddr::clear_tarlsmname() {
  tarlsmname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqFileAddr::tarlsmname() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFileAddr.tarLSMName)
  return tarlsmname_.GetNoArena();
}
inline void reqFileAddr::set_tarlsmname(const ::std::string& value) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFileAddr.tarLSMName)
}
#if LANG_CXX11
inline void reqFileAddr::set_tarlsmname(::std::string&& value) {
  
  tarlsmname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqFileAddr.tarLSMName)
}
#endif
inline void reqFileAddr::set_tarlsmname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqFileAddr.tarLSMName)
}
inline void reqFileAddr::set_tarlsmname(const char* value, size_t size) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqFileAddr.tarLSMName)
}
inline ::std::string* reqFileAddr::mutable_tarlsmname() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqFileAddr.tarLSMName)
  return tarlsmname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqFileAddr::release_tarlsmname() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqFileAddr.tarLSMName)
  
  return tarlsmname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqFileAddr::set_allocated_tarlsmname(::std::string* tarlsmname) {
  if (tarlsmname != NULL) {
    
  } else {
    
  }
  tarlsmname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tarlsmname);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqFileAddr.tarLSMName)
}

// .DDRCommProto.reqFileAddr.eFileTypes fileType = 2;
inline void reqFileAddr::clear_filetype() {
  filetype_ = 0;
}
inline ::DDRCommProto::reqFileAddr_eFileTypes reqFileAddr::filetype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFileAddr.fileType)
  return static_cast< ::DDRCommProto::reqFileAddr_eFileTypes >(filetype_);
}
inline void reqFileAddr::set_filetype(::DDRCommProto::reqFileAddr_eFileTypes value) {
  
  filetype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFileAddr.fileType)
}

// repeated string fileNames = 3;
inline int reqFileAddr::filenames_size() const {
  return filenames_.size();
}
inline void reqFileAddr::clear_filenames() {
  filenames_.Clear();
}
inline const ::std::string& reqFileAddr::filenames(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFileAddr.fileNames)
  return filenames_.Get(index);
}
inline ::std::string* reqFileAddr::mutable_filenames(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqFileAddr.fileNames)
  return filenames_.Mutable(index);
}
inline void reqFileAddr::set_filenames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFileAddr.fileNames)
  filenames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void reqFileAddr::set_filenames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFileAddr.fileNames)
  filenames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void reqFileAddr::set_filenames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqFileAddr.fileNames)
}
inline void reqFileAddr::set_filenames(int index, const char* value, size_t size) {
  filenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqFileAddr.fileNames)
}
inline ::std::string* reqFileAddr::add_filenames() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.reqFileAddr.fileNames)
  return filenames_.Add();
}
inline void reqFileAddr::add_filenames(const ::std::string& value) {
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.reqFileAddr.fileNames)
}
#if LANG_CXX11
inline void reqFileAddr::add_filenames(::std::string&& value) {
  filenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.reqFileAddr.fileNames)
}
#endif
inline void reqFileAddr::add_filenames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.reqFileAddr.fileNames)
}
inline void reqFileAddr::add_filenames(const char* value, size_t size) {
  filenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.reqFileAddr.fileNames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
reqFileAddr::filenames() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.reqFileAddr.fileNames)
  return filenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
reqFileAddr::mutable_filenames() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.reqFileAddr.fileNames)
  return &filenames_;
}

// -------------------------------------------------------------------

// respFileAddr

// string tarLSMName = 1;
inline void respFileAddr::clear_tarlsmname() {
  tarlsmname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& respFileAddr::tarlsmname() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFileAddr.tarLSMName)
  return tarlsmname_.GetNoArena();
}
inline void respFileAddr::set_tarlsmname(const ::std::string& value) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.respFileAddr.tarLSMName)
}
#if LANG_CXX11
inline void respFileAddr::set_tarlsmname(::std::string&& value) {
  
  tarlsmname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.respFileAddr.tarLSMName)
}
#endif
inline void respFileAddr::set_tarlsmname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFileAddr.tarLSMName)
}
inline void respFileAddr::set_tarlsmname(const char* value, size_t size) {
  
  tarlsmname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFileAddr.tarLSMName)
}
inline ::std::string* respFileAddr::mutable_tarlsmname() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFileAddr.tarLSMName)
  return tarlsmname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* respFileAddr::release_tarlsmname() {
  // @@protoc_insertion_point(field_release:DDRCommProto.respFileAddr.tarLSMName)
  
  return tarlsmname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void respFileAddr::set_allocated_tarlsmname(::std::string* tarlsmname) {
  if (tarlsmname != NULL) {
    
  } else {
    
  }
  tarlsmname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tarlsmname);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.respFileAddr.tarLSMName)
}

// .DDRCommProto.respFileAddr.eFileTypes fileType = 2;
inline void respFileAddr::clear_filetype() {
  filetype_ = 0;
}
inline ::DDRCommProto::respFileAddr_eFileTypes respFileAddr::filetype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFileAddr.fileType)
  return static_cast< ::DDRCommProto::respFileAddr_eFileTypes >(filetype_);
}
inline void respFileAddr::set_filetype(::DDRCommProto::respFileAddr_eFileTypes value) {
  
  filetype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respFileAddr.fileType)
}

// repeated string fileNames = 3;
inline int respFileAddr::filenames_size() const {
  return filenames_.size();
}
inline void respFileAddr::clear_filenames() {
  filenames_.Clear();
}
inline const ::std::string& respFileAddr::filenames(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFileAddr.fileNames)
  return filenames_.Get(index);
}
inline ::std::string* respFileAddr::mutable_filenames(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFileAddr.fileNames)
  return filenames_.Mutable(index);
}
inline void respFileAddr::set_filenames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFileAddr.fileNames)
  filenames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void respFileAddr::set_filenames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFileAddr.fileNames)
  filenames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void respFileAddr::set_filenames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFileAddr.fileNames)
}
inline void respFileAddr::set_filenames(int index, const char* value, size_t size) {
  filenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFileAddr.fileNames)
}
inline ::std::string* respFileAddr::add_filenames() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.respFileAddr.fileNames)
  return filenames_.Add();
}
inline void respFileAddr::add_filenames(const ::std::string& value) {
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.respFileAddr.fileNames)
}
#if LANG_CXX11
inline void respFileAddr::add_filenames(::std::string&& value) {
  filenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.respFileAddr.fileNames)
}
#endif
inline void respFileAddr::add_filenames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  filenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.respFileAddr.fileNames)
}
inline void respFileAddr::add_filenames(const char* value, size_t size) {
  filenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.respFileAddr.fileNames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
respFileAddr::filenames() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.respFileAddr.fileNames)
  return filenames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
respFileAddr::mutable_filenames() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.respFileAddr.fileNames)
  return &filenames_;
}

// repeated string fileAddr = 4;
inline int respFileAddr::fileaddr_size() const {
  return fileaddr_.size();
}
inline void respFileAddr::clear_fileaddr() {
  fileaddr_.Clear();
}
inline const ::std::string& respFileAddr::fileaddr(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFileAddr.fileAddr)
  return fileaddr_.Get(index);
}
inline ::std::string* respFileAddr::mutable_fileaddr(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFileAddr.fileAddr)
  return fileaddr_.Mutable(index);
}
inline void respFileAddr::set_fileaddr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFileAddr.fileAddr)
  fileaddr_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void respFileAddr::set_fileaddr(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.respFileAddr.fileAddr)
  fileaddr_.Mutable(index)->assign(std::move(value));
}
#endif
inline void respFileAddr::set_fileaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fileaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFileAddr.fileAddr)
}
inline void respFileAddr::set_fileaddr(int index, const char* value, size_t size) {
  fileaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFileAddr.fileAddr)
}
inline ::std::string* respFileAddr::add_fileaddr() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.respFileAddr.fileAddr)
  return fileaddr_.Add();
}
inline void respFileAddr::add_fileaddr(const ::std::string& value) {
  fileaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.respFileAddr.fileAddr)
}
#if LANG_CXX11
inline void respFileAddr::add_fileaddr(::std::string&& value) {
  fileaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.respFileAddr.fileAddr)
}
#endif
inline void respFileAddr::add_fileaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fileaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.respFileAddr.fileAddr)
}
inline void respFileAddr::add_fileaddr(const char* value, size_t size) {
  fileaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.respFileAddr.fileAddr)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
respFileAddr::fileaddr() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.respFileAddr.fileAddr)
  return fileaddr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
respFileAddr::mutable_fileaddr() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.respFileAddr.fileAddr)
  return &fileaddr_;
}

// -------------------------------------------------------------------

// reqStatus

// string statusMsg = 1;
inline void reqStatus::clear_statusmsg() {
  statusmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqStatus::statusmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqStatus.statusMsg)
  return statusmsg_.GetNoArena();
}
inline void reqStatus::set_statusmsg(const ::std::string& value) {
  
  statusmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqStatus.statusMsg)
}
#if LANG_CXX11
inline void reqStatus::set_statusmsg(::std::string&& value) {
  
  statusmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqStatus.statusMsg)
}
#endif
inline void reqStatus::set_statusmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  statusmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqStatus.statusMsg)
}
inline void reqStatus::set_statusmsg(const char* value, size_t size) {
  
  statusmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqStatus.statusMsg)
}
inline ::std::string* reqStatus::mutable_statusmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqStatus.statusMsg)
  return statusmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqStatus::release_statusmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqStatus.statusMsg)
  
  return statusmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqStatus::set_allocated_statusmsg(::std::string* statusmsg) {
  if (statusmsg != NULL) {
    
  } else {
    
  }
  statusmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), statusmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqStatus.statusMsg)
}

// -------------------------------------------------------------------

// reqAlarm

// string alarmMsg = 1;
inline void reqAlarm::clear_alarmmsg() {
  alarmmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqAlarm::alarmmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqAlarm.alarmMsg)
  return alarmmsg_.GetNoArena();
}
inline void reqAlarm::set_alarmmsg(const ::std::string& value) {
  
  alarmmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqAlarm.alarmMsg)
}
#if LANG_CXX11
inline void reqAlarm::set_alarmmsg(::std::string&& value) {
  
  alarmmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqAlarm.alarmMsg)
}
#endif
inline void reqAlarm::set_alarmmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  alarmmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqAlarm.alarmMsg)
}
inline void reqAlarm::set_alarmmsg(const char* value, size_t size) {
  
  alarmmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqAlarm.alarmMsg)
}
inline ::std::string* reqAlarm::mutable_alarmmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqAlarm.alarmMsg)
  return alarmmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqAlarm::release_alarmmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqAlarm.alarmMsg)
  
  return alarmmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqAlarm::set_allocated_alarmmsg(::std::string* alarmmsg) {
  if (alarmmsg != NULL) {
    
  } else {
    
  }
  alarmmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alarmmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqAlarm.alarmMsg)
}

// -------------------------------------------------------------------

// reqTextChat

// string chatText = 1;
inline void reqTextChat::clear_chattext() {
  chattext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqTextChat::chattext() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTextChat.chatText)
  return chattext_.GetNoArena();
}
inline void reqTextChat::set_chattext(const ::std::string& value) {
  
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTextChat.chatText)
}
#if LANG_CXX11
inline void reqTextChat::set_chattext(::std::string&& value) {
  
  chattext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqTextChat.chatText)
}
#endif
inline void reqTextChat::set_chattext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqTextChat.chatText)
}
inline void reqTextChat::set_chattext(const char* value, size_t size) {
  
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqTextChat.chatText)
}
inline ::std::string* reqTextChat::mutable_chattext() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqTextChat.chatText)
  return chattext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqTextChat::release_chattext() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqTextChat.chatText)
  
  return chattext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqTextChat::set_allocated_chattext(::std::string* chattext) {
  if (chattext != NULL) {
    
  } else {
    
  }
  chattext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chattext);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqTextChat.chatText)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DDRCommProto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DDRCommProto::CommonHeader_eFlowDir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::CommonHeader_eFlowDir>() {
  return ::DDRCommProto::CommonHeader_eFlowDir_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::CommonHeader_eSrcCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::CommonHeader_eSrcCondition>() {
  return ::DDRCommProto::CommonHeader_eSrcCondition_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::CommonHeader_eForwardingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::CommonHeader_eForwardingType>() {
  return ::DDRCommProto::CommonHeader_eForwardingType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::CommonHeader_eSrcRecType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::CommonHeader_eSrcRecType>() {
  return ::DDRCommProto::CommonHeader_eSrcRecType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqLogin_eCltType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqLogin_eCltType>() {
  return ::DDRCommProto::reqLogin_eCltType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respLogin_eLoginRetCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respLogin_eLoginRetCode>() {
  return ::DDRCommProto::respLogin_eLoginRetCode_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respLogin_eCltType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respLogin_eCltType>() {
  return ::DDRCommProto::respLogin_eCltType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqTalk_eCallerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqTalk_eCallerType>() {
  return ::DDRCommProto::reqTalk_eCallerType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respTalk_eReceiverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respTalk_eReceiverType>() {
  return ::DDRCommProto::respTalk_eReceiverType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqFile_eFileTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqFile_eFileTypes>() {
  return ::DDRCommProto::reqFile_eFileTypes_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respFile_eFileTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respFile_eFileTypes>() {
  return ::DDRCommProto::respFile_eFileTypes_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqFileAddr_eFileTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqFileAddr_eFileTypes>() {
  return ::DDRCommProto::reqFileAddr_eFileTypes_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respFileAddr_eFileTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respFileAddr_eFileTypes>() {
  return ::DDRCommProto::respFileAddr_eFileTypes_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_BaseCmd_2eproto
