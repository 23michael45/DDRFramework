// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseCmd.proto

#ifndef PROTOBUF_INCLUDED_BaseCmd_2eproto
#define PROTOBUF_INCLUDED_BaseCmd_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_BaseCmd_2eproto 

namespace protobuf_BaseCmd_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_BaseCmd_2eproto
namespace DDRCommProto {
class CommonHeader;
class CommonHeaderDefaultTypeInternal;
extern CommonHeaderDefaultTypeInternal _CommonHeader_default_instance_;
class bcLSAddr;
class bcLSAddrDefaultTypeInternal;
extern bcLSAddrDefaultTypeInternal _bcLSAddr_default_instance_;
class cmd;
class cmdDefaultTypeInternal;
extern cmdDefaultTypeInternal _cmd_default_instance_;
class heartBeat;
class heartBeatDefaultTypeInternal;
extern heartBeatDefaultTypeInternal _heartBeat_default_instance_;
class notifyAVStream;
class notifyAVStreamDefaultTypeInternal;
extern notifyAVStreamDefaultTypeInternal _notifyAVStream_default_instance_;
class notifyAVStream_fullChannelInfo;
class notifyAVStream_fullChannelInfoDefaultTypeInternal;
extern notifyAVStream_fullChannelInfoDefaultTypeInternal _notifyAVStream_fullChannelInfo_default_instance_;
class notifyAlarm;
class notifyAlarmDefaultTypeInternal;
extern notifyAlarmDefaultTypeInternal _notifyAlarm_default_instance_;
class notifySerAccess;
class notifySerAccessDefaultTypeInternal;
extern notifySerAccessDefaultTypeInternal _notifySerAccess_default_instance_;
class notifyStatus;
class notifyStatusDefaultTypeInternal;
extern notifyStatusDefaultTypeInternal _notifyStatus_default_instance_;
class notifyTerminalAccess;
class notifyTerminalAccessDefaultTypeInternal;
extern notifyTerminalAccessDefaultTypeInternal _notifyTerminalAccess_default_instance_;
class notifyTextChat;
class notifyTextChatDefaultTypeInternal;
extern notifyTextChatDefaultTypeInternal _notifyTextChat_default_instance_;
class reqFile;
class reqFileDefaultTypeInternal;
extern reqFileDefaultTypeInternal _reqFile_default_instance_;
class reqLogin;
class reqLoginDefaultTypeInternal;
extern reqLoginDefaultTypeInternal _reqLogin_default_instance_;
class reqLogin_msgAVStreamReq;
class reqLogin_msgAVStreamReqDefaultTypeInternal;
extern reqLogin_msgAVStreamReqDefaultTypeInternal _reqLogin_msgAVStreamReq_default_instance_;
class reqTalk;
class reqTalkDefaultTypeInternal;
extern reqTalkDefaultTypeInternal _reqTalk_default_instance_;
class respCmd;
class respCmdDefaultTypeInternal;
extern respCmdDefaultTypeInternal _respCmd_default_instance_;
class respFile;
class respFileDefaultTypeInternal;
extern respFileDefaultTypeInternal _respFile_default_instance_;
class respLogin;
class respLoginDefaultTypeInternal;
extern respLoginDefaultTypeInternal _respLogin_default_instance_;
class respTalk;
class respTalkDefaultTypeInternal;
extern respTalkDefaultTypeInternal _respTalk_default_instance_;
}  // namespace DDRCommProto
namespace google {
namespace protobuf {
template<> ::DDRCommProto::CommonHeader* Arena::CreateMaybeMessage<::DDRCommProto::CommonHeader>(Arena*);
template<> ::DDRCommProto::bcLSAddr* Arena::CreateMaybeMessage<::DDRCommProto::bcLSAddr>(Arena*);
template<> ::DDRCommProto::cmd* Arena::CreateMaybeMessage<::DDRCommProto::cmd>(Arena*);
template<> ::DDRCommProto::heartBeat* Arena::CreateMaybeMessage<::DDRCommProto::heartBeat>(Arena*);
template<> ::DDRCommProto::notifyAVStream* Arena::CreateMaybeMessage<::DDRCommProto::notifyAVStream>(Arena*);
template<> ::DDRCommProto::notifyAVStream_fullChannelInfo* Arena::CreateMaybeMessage<::DDRCommProto::notifyAVStream_fullChannelInfo>(Arena*);
template<> ::DDRCommProto::notifyAlarm* Arena::CreateMaybeMessage<::DDRCommProto::notifyAlarm>(Arena*);
template<> ::DDRCommProto::notifySerAccess* Arena::CreateMaybeMessage<::DDRCommProto::notifySerAccess>(Arena*);
template<> ::DDRCommProto::notifyStatus* Arena::CreateMaybeMessage<::DDRCommProto::notifyStatus>(Arena*);
template<> ::DDRCommProto::notifyTerminalAccess* Arena::CreateMaybeMessage<::DDRCommProto::notifyTerminalAccess>(Arena*);
template<> ::DDRCommProto::notifyTextChat* Arena::CreateMaybeMessage<::DDRCommProto::notifyTextChat>(Arena*);
template<> ::DDRCommProto::reqFile* Arena::CreateMaybeMessage<::DDRCommProto::reqFile>(Arena*);
template<> ::DDRCommProto::reqLogin* Arena::CreateMaybeMessage<::DDRCommProto::reqLogin>(Arena*);
template<> ::DDRCommProto::reqLogin_msgAVStreamReq* Arena::CreateMaybeMessage<::DDRCommProto::reqLogin_msgAVStreamReq>(Arena*);
template<> ::DDRCommProto::reqTalk* Arena::CreateMaybeMessage<::DDRCommProto::reqTalk>(Arena*);
template<> ::DDRCommProto::respCmd* Arena::CreateMaybeMessage<::DDRCommProto::respCmd>(Arena*);
template<> ::DDRCommProto::respFile* Arena::CreateMaybeMessage<::DDRCommProto::respFile>(Arena*);
template<> ::DDRCommProto::respLogin* Arena::CreateMaybeMessage<::DDRCommProto::respLogin>(Arena*);
template<> ::DDRCommProto::respTalk* Arena::CreateMaybeMessage<::DDRCommProto::respTalk>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace DDRCommProto {

enum CommonHeader_eFlowDir {
  CommonHeader_eFlowDir_RS2M = 0,
  CommonHeader_eFlowDir_RS2RR = 1,
  CommonHeader_eFlowDir_RR2RS = 2,
  CommonHeader_eFlowDir_LS2C = 3,
  CommonHeader_eFlowDir_C2LS = 4,
  CommonHeader_eFlowDir_LS2LSM = 5,
  CommonHeader_eFlowDir_LSM2LS = 6,
  CommonHeader_eFlowDir_CommonHeader_eFlowDir_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommonHeader_eFlowDir_CommonHeader_eFlowDir_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommonHeader_eFlowDir_IsValid(int value);
const CommonHeader_eFlowDir CommonHeader_eFlowDir_eFlowDir_MIN = CommonHeader_eFlowDir_RS2M;
const CommonHeader_eFlowDir CommonHeader_eFlowDir_eFlowDir_MAX = CommonHeader_eFlowDir_LSM2LS;
const int CommonHeader_eFlowDir_eFlowDir_ARRAYSIZE = CommonHeader_eFlowDir_eFlowDir_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonHeader_eFlowDir_descriptor();
inline const ::std::string& CommonHeader_eFlowDir_Name(CommonHeader_eFlowDir value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonHeader_eFlowDir_descriptor(), value);
}
inline bool CommonHeader_eFlowDir_Parse(
    const ::std::string& name, CommonHeader_eFlowDir* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonHeader_eFlowDir>(
    CommonHeader_eFlowDir_descriptor(), name, value);
}
enum CommonHeader_eDestType {
  CommonHeader_eDestType_NoDest = 0,
  CommonHeader_eDestType_LSMName = 1,
  CommonHeader_eDestType_Routing = 2,
  CommonHeader_eDestType_CommonHeader_eDestType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommonHeader_eDestType_CommonHeader_eDestType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommonHeader_eDestType_IsValid(int value);
const CommonHeader_eDestType CommonHeader_eDestType_eDestType_MIN = CommonHeader_eDestType_NoDest;
const CommonHeader_eDestType CommonHeader_eDestType_eDestType_MAX = CommonHeader_eDestType_Routing;
const int CommonHeader_eDestType_eDestType_ARRAYSIZE = CommonHeader_eDestType_eDestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonHeader_eDestType_descriptor();
inline const ::std::string& CommonHeader_eDestType_Name(CommonHeader_eDestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonHeader_eDestType_descriptor(), value);
}
inline bool CommonHeader_eDestType_Parse(
    const ::std::string& name, CommonHeader_eDestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonHeader_eDestType>(
    CommonHeader_eDestType_descriptor(), name, value);
}
enum reqLogin_eCltType {
  reqLogin_eCltType_client = 0,
  reqLogin_eCltType_androidClient = 1,
  reqLogin_eCltType_LSM = 2,
  reqLogin_eCltType_reqLogin_eCltType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqLogin_eCltType_reqLogin_eCltType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqLogin_eCltType_IsValid(int value);
const reqLogin_eCltType reqLogin_eCltType_eCltType_MIN = reqLogin_eCltType_client;
const reqLogin_eCltType reqLogin_eCltType_eCltType_MAX = reqLogin_eCltType_LSM;
const int reqLogin_eCltType_eCltType_ARRAYSIZE = reqLogin_eCltType_eCltType_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqLogin_eCltType_descriptor();
inline const ::std::string& reqLogin_eCltType_Name(reqLogin_eCltType value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqLogin_eCltType_descriptor(), value);
}
inline bool reqLogin_eCltType_Parse(
    const ::std::string& name, reqLogin_eCltType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqLogin_eCltType>(
    reqLogin_eCltType_descriptor(), name, value);
}
enum respLogin_eLoginRetCode {
  respLogin_eLoginRetCode_success = 0,
  respLogin_eLoginRetCode_server_busy = 1,
  respLogin_eLoginRetCode_server_limit_reached = 2,
  respLogin_eLoginRetCode_UID_error = 3,
  respLogin_eLoginRetCode_incorrect_password = 4,
  respLogin_eLoginRetCode_respLogin_eLoginRetCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respLogin_eLoginRetCode_respLogin_eLoginRetCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respLogin_eLoginRetCode_IsValid(int value);
const respLogin_eLoginRetCode respLogin_eLoginRetCode_eLoginRetCode_MIN = respLogin_eLoginRetCode_success;
const respLogin_eLoginRetCode respLogin_eLoginRetCode_eLoginRetCode_MAX = respLogin_eLoginRetCode_incorrect_password;
const int respLogin_eLoginRetCode_eLoginRetCode_ARRAYSIZE = respLogin_eLoginRetCode_eLoginRetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* respLogin_eLoginRetCode_descriptor();
inline const ::std::string& respLogin_eLoginRetCode_Name(respLogin_eLoginRetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    respLogin_eLoginRetCode_descriptor(), value);
}
inline bool respLogin_eLoginRetCode_Parse(
    const ::std::string& name, respLogin_eLoginRetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respLogin_eLoginRetCode>(
    respLogin_eLoginRetCode_descriptor(), name, value);
}
enum respLogin_eCltType {
  respLogin_eCltType_client = 0,
  respLogin_eCltType_androidClient = 1,
  respLogin_eCltType_LSM = 2,
  respLogin_eCltType_respLogin_eCltType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respLogin_eCltType_respLogin_eCltType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respLogin_eCltType_IsValid(int value);
const respLogin_eCltType respLogin_eCltType_eCltType_MIN = respLogin_eCltType_client;
const respLogin_eCltType respLogin_eCltType_eCltType_MAX = respLogin_eCltType_LSM;
const int respLogin_eCltType_eCltType_ARRAYSIZE = respLogin_eCltType_eCltType_MAX + 1;

const ::google::protobuf::EnumDescriptor* respLogin_eCltType_descriptor();
inline const ::std::string& respLogin_eCltType_Name(respLogin_eCltType value) {
  return ::google::protobuf::internal::NameOfEnum(
    respLogin_eCltType_descriptor(), value);
}
inline bool respLogin_eCltType_Parse(
    const ::std::string& name, respLogin_eCltType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respLogin_eCltType>(
    respLogin_eCltType_descriptor(), name, value);
}
enum reqTalk_eCallerType {
  reqTalk_eCallerType_client = 0,
  reqTalk_eCallerType_monitor = 1,
  reqTalk_eCallerType_robot_LSM = 2,
  reqTalk_eCallerType_reqTalk_eCallerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqTalk_eCallerType_reqTalk_eCallerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqTalk_eCallerType_IsValid(int value);
const reqTalk_eCallerType reqTalk_eCallerType_eCallerType_MIN = reqTalk_eCallerType_client;
const reqTalk_eCallerType reqTalk_eCallerType_eCallerType_MAX = reqTalk_eCallerType_robot_LSM;
const int reqTalk_eCallerType_eCallerType_ARRAYSIZE = reqTalk_eCallerType_eCallerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqTalk_eCallerType_descriptor();
inline const ::std::string& reqTalk_eCallerType_Name(reqTalk_eCallerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqTalk_eCallerType_descriptor(), value);
}
inline bool reqTalk_eCallerType_Parse(
    const ::std::string& name, reqTalk_eCallerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqTalk_eCallerType>(
    reqTalk_eCallerType_descriptor(), name, value);
}
enum respTalk_eReceiverType {
  respTalk_eReceiverType_client = 0,
  respTalk_eReceiverType_monitor = 1,
  respTalk_eReceiverType_robot_LSM = 2,
  respTalk_eReceiverType_respTalk_eReceiverType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respTalk_eReceiverType_respTalk_eReceiverType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respTalk_eReceiverType_IsValid(int value);
const respTalk_eReceiverType respTalk_eReceiverType_eReceiverType_MIN = respTalk_eReceiverType_client;
const respTalk_eReceiverType respTalk_eReceiverType_eReceiverType_MAX = respTalk_eReceiverType_robot_LSM;
const int respTalk_eReceiverType_eReceiverType_ARRAYSIZE = respTalk_eReceiverType_eReceiverType_MAX + 1;

const ::google::protobuf::EnumDescriptor* respTalk_eReceiverType_descriptor();
inline const ::std::string& respTalk_eReceiverType_Name(respTalk_eReceiverType value) {
  return ::google::protobuf::internal::NameOfEnum(
    respTalk_eReceiverType_descriptor(), value);
}
inline bool respTalk_eReceiverType_Parse(
    const ::std::string& name, respTalk_eReceiverType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respTalk_eReceiverType>(
    respTalk_eReceiverType_descriptor(), name, value);
}
enum reqFile_eZipFormat {
  reqFile_eZipFormat_noZip = 0,
  reqFile_eZipFormat_Zip = 1,
  reqFile_eZipFormat_reqFile_eZipFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  reqFile_eZipFormat_reqFile_eZipFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool reqFile_eZipFormat_IsValid(int value);
const reqFile_eZipFormat reqFile_eZipFormat_eZipFormat_MIN = reqFile_eZipFormat_noZip;
const reqFile_eZipFormat reqFile_eZipFormat_eZipFormat_MAX = reqFile_eZipFormat_Zip;
const int reqFile_eZipFormat_eZipFormat_ARRAYSIZE = reqFile_eZipFormat_eZipFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* reqFile_eZipFormat_descriptor();
inline const ::std::string& reqFile_eZipFormat_Name(reqFile_eZipFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    reqFile_eZipFormat_descriptor(), value);
}
inline bool reqFile_eZipFormat_Parse(
    const ::std::string& name, reqFile_eZipFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<reqFile_eZipFormat>(
    reqFile_eZipFormat_descriptor(), name, value);
}
enum respFile_eZipFormat {
  respFile_eZipFormat_noZip = 0,
  respFile_eZipFormat_Zip = 1,
  respFile_eZipFormat_respFile_eZipFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  respFile_eZipFormat_respFile_eZipFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool respFile_eZipFormat_IsValid(int value);
const respFile_eZipFormat respFile_eZipFormat_eZipFormat_MIN = respFile_eZipFormat_noZip;
const respFile_eZipFormat respFile_eZipFormat_eZipFormat_MAX = respFile_eZipFormat_Zip;
const int respFile_eZipFormat_eZipFormat_ARRAYSIZE = respFile_eZipFormat_eZipFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* respFile_eZipFormat_descriptor();
inline const ::std::string& respFile_eZipFormat_Name(respFile_eZipFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    respFile_eZipFormat_descriptor(), value);
}
inline bool respFile_eZipFormat_Parse(
    const ::std::string& name, respFile_eZipFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<respFile_eZipFormat>(
    respFile_eZipFormat_descriptor(), name, value);
}
// ===================================================================

class CommonHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.CommonHeader) */ {
 public:
  CommonHeader();
  virtual ~CommonHeader();

  CommonHeader(const CommonHeader& from);

  inline CommonHeader& operator=(const CommonHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommonHeader(CommonHeader&& from) noexcept
    : CommonHeader() {
    *this = ::std::move(from);
  }

  inline CommonHeader& operator=(CommonHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonHeader* internal_default_instance() {
    return reinterpret_cast<const CommonHeader*>(
               &_CommonHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CommonHeader* other);
  friend void swap(CommonHeader& a, CommonHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonHeader* New() const final {
    return CreateMaybeMessage<CommonHeader>(NULL);
  }

  CommonHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommonHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommonHeader& from);
  void MergeFrom(const CommonHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CommonHeader_eFlowDir eFlowDir;
  static const eFlowDir RS2M =
    CommonHeader_eFlowDir_RS2M;
  static const eFlowDir RS2RR =
    CommonHeader_eFlowDir_RS2RR;
  static const eFlowDir RR2RS =
    CommonHeader_eFlowDir_RR2RS;
  static const eFlowDir LS2C =
    CommonHeader_eFlowDir_LS2C;
  static const eFlowDir C2LS =
    CommonHeader_eFlowDir_C2LS;
  static const eFlowDir LS2LSM =
    CommonHeader_eFlowDir_LS2LSM;
  static const eFlowDir LSM2LS =
    CommonHeader_eFlowDir_LSM2LS;
  static inline bool eFlowDir_IsValid(int value) {
    return CommonHeader_eFlowDir_IsValid(value);
  }
  static const eFlowDir eFlowDir_MIN =
    CommonHeader_eFlowDir_eFlowDir_MIN;
  static const eFlowDir eFlowDir_MAX =
    CommonHeader_eFlowDir_eFlowDir_MAX;
  static const int eFlowDir_ARRAYSIZE =
    CommonHeader_eFlowDir_eFlowDir_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eFlowDir_descriptor() {
    return CommonHeader_eFlowDir_descriptor();
  }
  static inline const ::std::string& eFlowDir_Name(eFlowDir value) {
    return CommonHeader_eFlowDir_Name(value);
  }
  static inline bool eFlowDir_Parse(const ::std::string& name,
      eFlowDir* value) {
    return CommonHeader_eFlowDir_Parse(name, value);
  }

  typedef CommonHeader_eDestType eDestType;
  static const eDestType NoDest =
    CommonHeader_eDestType_NoDest;
  static const eDestType LSMName =
    CommonHeader_eDestType_LSMName;
  static const eDestType Routing =
    CommonHeader_eDestType_Routing;
  static inline bool eDestType_IsValid(int value) {
    return CommonHeader_eDestType_IsValid(value);
  }
  static const eDestType eDestType_MIN =
    CommonHeader_eDestType_eDestType_MIN;
  static const eDestType eDestType_MAX =
    CommonHeader_eDestType_eDestType_MAX;
  static const int eDestType_ARRAYSIZE =
    CommonHeader_eDestType_eDestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eDestType_descriptor() {
    return CommonHeader_eDestType_descriptor();
  }
  static inline const ::std::string& eDestType_Name(eDestType value) {
    return CommonHeader_eDestType_Name(value);
  }
  static inline bool eDestType_Parse(const ::std::string& name,
      eDestType* value) {
    return CommonHeader_eDestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DDRCommProto.CommonHeader.eFlowDir flowDirection = 2;
  int flowdirection_size() const;
  void clear_flowdirection();
  static const int kFlowDirectionFieldNumber = 2;
  ::DDRCommProto::CommonHeader_eFlowDir flowdirection(int index) const;
  void set_flowdirection(int index, ::DDRCommProto::CommonHeader_eFlowDir value);
  void add_flowdirection(::DDRCommProto::CommonHeader_eFlowDir value);
  const ::google::protobuf::RepeatedField<int>& flowdirection() const;
  ::google::protobuf::RepeatedField<int>* mutable_flowdirection();

  // repeated .DDRCommProto.CommonHeader.eDestType destType = 3;
  int desttype_size() const;
  void clear_desttype();
  static const int kDestTypeFieldNumber = 3;
  ::DDRCommProto::CommonHeader_eDestType desttype(int index) const;
  void set_desttype(int index, ::DDRCommProto::CommonHeader_eDestType value);
  void add_desttype(::DDRCommProto::CommonHeader_eDestType value);
  const ::google::protobuf::RepeatedField<int>& desttype() const;
  ::google::protobuf::RepeatedField<int>* mutable_desttype();

  // repeated string destInfo = 4;
  int destinfo_size() const;
  void clear_destinfo();
  static const int kDestInfoFieldNumber = 4;
  const ::std::string& destinfo(int index) const;
  ::std::string* mutable_destinfo(int index);
  void set_destinfo(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_destinfo(int index, ::std::string&& value);
  #endif
  void set_destinfo(int index, const char* value);
  void set_destinfo(int index, const char* value, size_t size);
  ::std::string* add_destinfo();
  void add_destinfo(const ::std::string& value);
  #if LANG_CXX11
  void add_destinfo(::std::string&& value);
  #endif
  void add_destinfo(const char* value);
  void add_destinfo(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& destinfo() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_destinfo();

  // string bodyType = 1;
  void clear_bodytype();
  static const int kBodyTypeFieldNumber = 1;
  const ::std::string& bodytype() const;
  void set_bodytype(const ::std::string& value);
  #if LANG_CXX11
  void set_bodytype(::std::string&& value);
  #endif
  void set_bodytype(const char* value);
  void set_bodytype(const char* value, size_t size);
  ::std::string* mutable_bodytype();
  ::std::string* release_bodytype();
  void set_allocated_bodytype(::std::string* bodytype);

  // @@protoc_insertion_point(class_scope:DDRCommProto.CommonHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> flowdirection_;
  mutable int _flowdirection_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> desttype_;
  mutable int _desttype_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> destinfo_;
  ::google::protobuf::internal::ArenaStringPtr bodytype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class heartBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.heartBeat) */ {
 public:
  heartBeat();
  virtual ~heartBeat();

  heartBeat(const heartBeat& from);

  inline heartBeat& operator=(const heartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  heartBeat(heartBeat&& from) noexcept
    : heartBeat() {
    *this = ::std::move(from);
  }

  inline heartBeat& operator=(heartBeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const heartBeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const heartBeat* internal_default_instance() {
    return reinterpret_cast<const heartBeat*>(
               &_heartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(heartBeat* other);
  friend void swap(heartBeat& a, heartBeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline heartBeat* New() const final {
    return CreateMaybeMessage<heartBeat>(NULL);
  }

  heartBeat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<heartBeat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const heartBeat& from);
  void MergeFrom(const heartBeat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(heartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string whatever = 1;
  void clear_whatever();
  static const int kWhateverFieldNumber = 1;
  const ::std::string& whatever() const;
  void set_whatever(const ::std::string& value);
  #if LANG_CXX11
  void set_whatever(::std::string&& value);
  #endif
  void set_whatever(const char* value);
  void set_whatever(const char* value, size_t size);
  ::std::string* mutable_whatever();
  ::std::string* release_whatever();
  void set_allocated_whatever(::std::string* whatever);

  // @@protoc_insertion_point(class_scope:DDRCommProto.heartBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr whatever_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bcLSAddr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.bcLSAddr) */ {
 public:
  bcLSAddr();
  virtual ~bcLSAddr();

  bcLSAddr(const bcLSAddr& from);

  inline bcLSAddr& operator=(const bcLSAddr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bcLSAddr(bcLSAddr&& from) noexcept
    : bcLSAddr() {
    *this = ::std::move(from);
  }

  inline bcLSAddr& operator=(bcLSAddr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const bcLSAddr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bcLSAddr* internal_default_instance() {
    return reinterpret_cast<const bcLSAddr*>(
               &_bcLSAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(bcLSAddr* other);
  friend void swap(bcLSAddr& a, bcLSAddr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bcLSAddr* New() const final {
    return CreateMaybeMessage<bcLSAddr>(NULL);
  }

  bcLSAddr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bcLSAddr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bcLSAddr& from);
  void MergeFrom(const bcLSAddr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bcLSAddr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ips = 2;
  int ips_size() const;
  void clear_ips();
  static const int kIpsFieldNumber = 2;
  const ::std::string& ips(int index) const;
  ::std::string* mutable_ips(int index);
  void set_ips(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ips(int index, ::std::string&& value);
  #endif
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  ::std::string* add_ips();
  void add_ips(const ::std::string& value);
  #if LANG_CXX11
  void add_ips(::std::string&& value);
  #endif
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ips();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.bcLSAddr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ips_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqLogin_msgAVStreamReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqLogin.msgAVStreamReq) */ {
 public:
  reqLogin_msgAVStreamReq();
  virtual ~reqLogin_msgAVStreamReq();

  reqLogin_msgAVStreamReq(const reqLogin_msgAVStreamReq& from);

  inline reqLogin_msgAVStreamReq& operator=(const reqLogin_msgAVStreamReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqLogin_msgAVStreamReq(reqLogin_msgAVStreamReq&& from) noexcept
    : reqLogin_msgAVStreamReq() {
    *this = ::std::move(from);
  }

  inline reqLogin_msgAVStreamReq& operator=(reqLogin_msgAVStreamReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqLogin_msgAVStreamReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqLogin_msgAVStreamReq* internal_default_instance() {
    return reinterpret_cast<const reqLogin_msgAVStreamReq*>(
               &_reqLogin_msgAVStreamReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(reqLogin_msgAVStreamReq* other);
  friend void swap(reqLogin_msgAVStreamReq& a, reqLogin_msgAVStreamReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqLogin_msgAVStreamReq* New() const final {
    return CreateMaybeMessage<reqLogin_msgAVStreamReq>(NULL);
  }

  reqLogin_msgAVStreamReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqLogin_msgAVStreamReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqLogin_msgAVStreamReq& from);
  void MergeFrom(const reqLogin_msgAVStreamReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqLogin_msgAVStreamReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chName = 2;
  void clear_chname();
  static const int kChNameFieldNumber = 2;
  const ::std::string& chname() const;
  void set_chname(const ::std::string& value);
  #if LANG_CXX11
  void set_chname(::std::string&& value);
  #endif
  void set_chname(const char* value);
  void set_chname(const char* value, size_t size);
  ::std::string* mutable_chname();
  ::std::string* release_chname();
  void set_allocated_chname(::std::string* chname);

  // int32 avType = 1;
  void clear_avtype();
  static const int kAvTypeFieldNumber = 1;
  ::google::protobuf::int32 avtype() const;
  void set_avtype(::google::protobuf::int32 value);

  // int32 bandwidthReq = 3;
  void clear_bandwidthreq();
  static const int kBandwidthReqFieldNumber = 3;
  ::google::protobuf::int32 bandwidthreq() const;
  void set_bandwidthreq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqLogin.msgAVStreamReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chname_;
  ::google::protobuf::int32 avtype_;
  ::google::protobuf::int32 bandwidthreq_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqLogin) */ {
 public:
  reqLogin();
  virtual ~reqLogin();

  reqLogin(const reqLogin& from);

  inline reqLogin& operator=(const reqLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqLogin(reqLogin&& from) noexcept
    : reqLogin() {
    *this = ::std::move(from);
  }

  inline reqLogin& operator=(reqLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqLogin* internal_default_instance() {
    return reinterpret_cast<const reqLogin*>(
               &_reqLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(reqLogin* other);
  friend void swap(reqLogin& a, reqLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqLogin* New() const final {
    return CreateMaybeMessage<reqLogin>(NULL);
  }

  reqLogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqLogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqLogin& from);
  void MergeFrom(const reqLogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqLogin_msgAVStreamReq msgAVStreamReq;

  typedef reqLogin_eCltType eCltType;
  static const eCltType client =
    reqLogin_eCltType_client;
  static const eCltType androidClient =
    reqLogin_eCltType_androidClient;
  static const eCltType LSM =
    reqLogin_eCltType_LSM;
  static inline bool eCltType_IsValid(int value) {
    return reqLogin_eCltType_IsValid(value);
  }
  static const eCltType eCltType_MIN =
    reqLogin_eCltType_eCltType_MIN;
  static const eCltType eCltType_MAX =
    reqLogin_eCltType_eCltType_MAX;
  static const int eCltType_ARRAYSIZE =
    reqLogin_eCltType_eCltType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCltType_descriptor() {
    return reqLogin_eCltType_descriptor();
  }
  static inline const ::std::string& eCltType_Name(eCltType value) {
    return reqLogin_eCltType_Name(value);
  }
  static inline bool eCltType_Parse(const ::std::string& name,
      eCltType* value) {
    return reqLogin_eCltType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DDRCommProto.reqLogin.msgAVStreamReq avStreamReq = 7;
  int avstreamreq_size() const;
  void clear_avstreamreq();
  static const int kAvStreamReqFieldNumber = 7;
  ::DDRCommProto::reqLogin_msgAVStreamReq* mutable_avstreamreq(int index);
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >*
      mutable_avstreamreq();
  const ::DDRCommProto::reqLogin_msgAVStreamReq& avstreamreq(int index) const;
  ::DDRCommProto::reqLogin_msgAVStreamReq* add_avstreamreq();
  const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >&
      avstreamreq() const;

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string robotID = 3;
  void clear_robotid();
  static const int kRobotIDFieldNumber = 3;
  const ::std::string& robotid() const;
  void set_robotid(const ::std::string& value);
  #if LANG_CXX11
  void set_robotid(::std::string&& value);
  #endif
  void set_robotid(const char* value);
  void set_robotid(const char* value, size_t size);
  ::std::string* mutable_robotid();
  ::std::string* release_robotid();
  void set_allocated_robotid(::std::string* robotid);

  // string robotPWD = 4;
  void clear_robotpwd();
  static const int kRobotPWDFieldNumber = 4;
  const ::std::string& robotpwd() const;
  void set_robotpwd(const ::std::string& value);
  #if LANG_CXX11
  void set_robotpwd(::std::string&& value);
  #endif
  void set_robotpwd(const char* value);
  void set_robotpwd(const char* value, size_t size);
  ::std::string* mutable_robotpwd();
  ::std::string* release_robotpwd();
  void set_allocated_robotpwd(::std::string* robotpwd);

  // .DDRCommProto.reqLogin.eCltType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::DDRCommProto::reqLogin_eCltType type() const;
  void set_type(::DDRCommProto::reqLogin_eCltType value);

  // int32 cltOpLv = 5;
  void clear_cltoplv();
  static const int kCltOpLvFieldNumber = 5;
  ::google::protobuf::int32 cltoplv() const;
  void set_cltoplv(::google::protobuf::int32 value);

  // int32 UID = 6;
  void clear_uid();
  static const int kUIDFieldNumber = 6;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq > avstreamreq_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr robotid_;
  ::google::protobuf::internal::ArenaStringPtr robotpwd_;
  int type_;
  ::google::protobuf::int32 cltoplv_;
  ::google::protobuf::int32 uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respLogin) */ {
 public:
  respLogin();
  virtual ~respLogin();

  respLogin(const respLogin& from);

  inline respLogin& operator=(const respLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respLogin(respLogin&& from) noexcept
    : respLogin() {
    *this = ::std::move(from);
  }

  inline respLogin& operator=(respLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respLogin* internal_default_instance() {
    return reinterpret_cast<const respLogin*>(
               &_respLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(respLogin* other);
  friend void swap(respLogin& a, respLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respLogin* New() const final {
    return CreateMaybeMessage<respLogin>(NULL);
  }

  respLogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respLogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respLogin& from);
  void MergeFrom(const respLogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respLogin_eLoginRetCode eLoginRetCode;
  static const eLoginRetCode success =
    respLogin_eLoginRetCode_success;
  static const eLoginRetCode server_busy =
    respLogin_eLoginRetCode_server_busy;
  static const eLoginRetCode server_limit_reached =
    respLogin_eLoginRetCode_server_limit_reached;
  static const eLoginRetCode UID_error =
    respLogin_eLoginRetCode_UID_error;
  static const eLoginRetCode incorrect_password =
    respLogin_eLoginRetCode_incorrect_password;
  static inline bool eLoginRetCode_IsValid(int value) {
    return respLogin_eLoginRetCode_IsValid(value);
  }
  static const eLoginRetCode eLoginRetCode_MIN =
    respLogin_eLoginRetCode_eLoginRetCode_MIN;
  static const eLoginRetCode eLoginRetCode_MAX =
    respLogin_eLoginRetCode_eLoginRetCode_MAX;
  static const int eLoginRetCode_ARRAYSIZE =
    respLogin_eLoginRetCode_eLoginRetCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eLoginRetCode_descriptor() {
    return respLogin_eLoginRetCode_descriptor();
  }
  static inline const ::std::string& eLoginRetCode_Name(eLoginRetCode value) {
    return respLogin_eLoginRetCode_Name(value);
  }
  static inline bool eLoginRetCode_Parse(const ::std::string& name,
      eLoginRetCode* value) {
    return respLogin_eLoginRetCode_Parse(name, value);
  }

  typedef respLogin_eCltType eCltType;
  static const eCltType client =
    respLogin_eCltType_client;
  static const eCltType androidClient =
    respLogin_eCltType_androidClient;
  static const eCltType LSM =
    respLogin_eCltType_LSM;
  static inline bool eCltType_IsValid(int value) {
    return respLogin_eCltType_IsValid(value);
  }
  static const eCltType eCltType_MIN =
    respLogin_eCltType_eCltType_MIN;
  static const eCltType eCltType_MAX =
    respLogin_eCltType_eCltType_MAX;
  static const int eCltType_ARRAYSIZE =
    respLogin_eCltType_eCltType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCltType_descriptor() {
    return respLogin_eCltType_descriptor();
  }
  static inline const ::std::string& eCltType_Name(eCltType value) {
    return respLogin_eCltType_Name(value);
  }
  static inline bool eCltType_Parse(const ::std::string& name,
      eCltType* value) {
    return respLogin_eCltType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .DDRCommProto.respLogin.eLoginRetCode retcode = 1;
  void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  ::DDRCommProto::respLogin_eLoginRetCode retcode() const;
  void set_retcode(::DDRCommProto::respLogin_eLoginRetCode value);

  // .DDRCommProto.respLogin.eCltType yourRole = 2;
  void clear_yourrole();
  static const int kYourRoleFieldNumber = 2;
  ::DDRCommProto::respLogin_eCltType yourrole() const;
  void set_yourrole(::DDRCommProto::respLogin_eCltType value);

  // int32 UID = 3;
  void clear_uid();
  static const int kUIDFieldNumber = 3;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int retcode_;
  int yourrole_;
  ::google::protobuf::int32 uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyTerminalAccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyTerminalAccess) */ {
 public:
  notifyTerminalAccess();
  virtual ~notifyTerminalAccess();

  notifyTerminalAccess(const notifyTerminalAccess& from);

  inline notifyTerminalAccess& operator=(const notifyTerminalAccess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyTerminalAccess(notifyTerminalAccess&& from) noexcept
    : notifyTerminalAccess() {
    *this = ::std::move(from);
  }

  inline notifyTerminalAccess& operator=(notifyTerminalAccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyTerminalAccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyTerminalAccess* internal_default_instance() {
    return reinterpret_cast<const notifyTerminalAccess*>(
               &_notifyTerminalAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(notifyTerminalAccess* other);
  friend void swap(notifyTerminalAccess& a, notifyTerminalAccess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyTerminalAccess* New() const final {
    return CreateMaybeMessage<notifyTerminalAccess>(NULL);
  }

  notifyTerminalAccess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyTerminalAccess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyTerminalAccess& from);
  void MergeFrom(const notifyTerminalAccess& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyTerminalAccess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string nameLSMs = 5;
  int namelsms_size() const;
  void clear_namelsms();
  static const int kNameLSMsFieldNumber = 5;
  const ::std::string& namelsms(int index) const;
  ::std::string* mutable_namelsms(int index);
  void set_namelsms(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_namelsms(int index, ::std::string&& value);
  #endif
  void set_namelsms(int index, const char* value);
  void set_namelsms(int index, const char* value, size_t size);
  ::std::string* add_namelsms();
  void add_namelsms(const ::std::string& value);
  #if LANG_CXX11
  void add_namelsms(::std::string&& value);
  #endif
  void add_namelsms(const char* value);
  void add_namelsms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& namelsms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_namelsms();

  // int32 bRRConnected2RS = 1;
  void clear_brrconnected2rs();
  static const int kBRRConnected2RSFieldNumber = 1;
  ::google::protobuf::int32 brrconnected2rs() const;
  void set_brrconnected2rs(::google::protobuf::int32 value);

  // int32 bOp = 2;
  void clear_bop();
  static const int kBOpFieldNumber = 2;
  ::google::protobuf::int32 bop() const;
  void set_bop(::google::protobuf::int32 value);

  // int32 nMonitors = 3;
  void clear_nmonitors();
  static const int kNMonitorsFieldNumber = 3;
  ::google::protobuf::int32 nmonitors() const;
  void set_nmonitors(::google::protobuf::int32 value);

  // int32 nClients = 4;
  void clear_nclients();
  static const int kNClientsFieldNumber = 4;
  ::google::protobuf::int32 nclients() const;
  void set_nclients(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyTerminalAccess)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> namelsms_;
  ::google::protobuf::int32 brrconnected2rs_;
  ::google::protobuf::int32 bop_;
  ::google::protobuf::int32 nmonitors_;
  ::google::protobuf::int32 nclients_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifySerAccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifySerAccess) */ {
 public:
  notifySerAccess();
  virtual ~notifySerAccess();

  notifySerAccess(const notifySerAccess& from);

  inline notifySerAccess& operator=(const notifySerAccess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifySerAccess(notifySerAccess&& from) noexcept
    : notifySerAccess() {
    *this = ::std::move(from);
  }

  inline notifySerAccess& operator=(notifySerAccess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifySerAccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifySerAccess* internal_default_instance() {
    return reinterpret_cast<const notifySerAccess*>(
               &_notifySerAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(notifySerAccess* other);
  friend void swap(notifySerAccess& a, notifySerAccess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifySerAccess* New() const final {
    return CreateMaybeMessage<notifySerAccess>(NULL);
  }

  notifySerAccess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifySerAccess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifySerAccess& from);
  void MergeFrom(const notifySerAccess& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifySerAccess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string namesLSM = 7;
  int nameslsm_size() const;
  void clear_nameslsm();
  static const int kNamesLSMFieldNumber = 7;
  const ::std::string& nameslsm(int index) const;
  ::std::string* mutable_nameslsm(int index);
  void set_nameslsm(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_nameslsm(int index, ::std::string&& value);
  #endif
  void set_nameslsm(int index, const char* value);
  void set_nameslsm(int index, const char* value, size_t size);
  ::std::string* add_nameslsm();
  void add_nameslsm(const ::std::string& value);
  #if LANG_CXX11
  void add_nameslsm(::std::string&& value);
  #endif
  void add_nameslsm(const char* value);
  void add_nameslsm(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& nameslsm() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nameslsm();

  // int32 nClients = 1;
  void clear_nclients();
  static const int kNClientsFieldNumber = 1;
  ::google::protobuf::int32 nclients() const;
  void set_nclients(::google::protobuf::int32 value);

  // int32 cTopOpLv = 2;
  void clear_ctopoplv();
  static const int kCTopOpLvFieldNumber = 2;
  ::google::protobuf::int32 ctopoplv() const;
  void set_ctopoplv(::google::protobuf::int32 value);

  // int64 cTopOpTime = 3;
  void clear_ctopoptime();
  static const int kCTopOpTimeFieldNumber = 3;
  ::google::protobuf::int64 ctopoptime() const;
  void set_ctopoptime(::google::protobuf::int64 value);

  // int32 nMonitors = 4;
  void clear_nmonitors();
  static const int kNMonitorsFieldNumber = 4;
  ::google::protobuf::int32 nmonitors() const;
  void set_nmonitors(::google::protobuf::int32 value);

  // int32 mTopOpLv = 5;
  void clear_mtopoplv();
  static const int kMTopOpLvFieldNumber = 5;
  ::google::protobuf::int32 mtopoplv() const;
  void set_mtopoplv(::google::protobuf::int32 value);

  // int32 mTopOpTime = 6;
  void clear_mtopoptime();
  static const int kMTopOpTimeFieldNumber = 6;
  ::google::protobuf::int32 mtopoptime() const;
  void set_mtopoptime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifySerAccess)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nameslsm_;
  ::google::protobuf::int32 nclients_;
  ::google::protobuf::int32 ctopoplv_;
  ::google::protobuf::int64 ctopoptime_;
  ::google::protobuf::int32 nmonitors_;
  ::google::protobuf::int32 mtopoplv_;
  ::google::protobuf::int32 mtopoptime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyAVStream_fullChannelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyAVStream.fullChannelInfo) */ {
 public:
  notifyAVStream_fullChannelInfo();
  virtual ~notifyAVStream_fullChannelInfo();

  notifyAVStream_fullChannelInfo(const notifyAVStream_fullChannelInfo& from);

  inline notifyAVStream_fullChannelInfo& operator=(const notifyAVStream_fullChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyAVStream_fullChannelInfo(notifyAVStream_fullChannelInfo&& from) noexcept
    : notifyAVStream_fullChannelInfo() {
    *this = ::std::move(from);
  }

  inline notifyAVStream_fullChannelInfo& operator=(notifyAVStream_fullChannelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyAVStream_fullChannelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyAVStream_fullChannelInfo* internal_default_instance() {
    return reinterpret_cast<const notifyAVStream_fullChannelInfo*>(
               &_notifyAVStream_fullChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(notifyAVStream_fullChannelInfo* other);
  friend void swap(notifyAVStream_fullChannelInfo& a, notifyAVStream_fullChannelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyAVStream_fullChannelInfo* New() const final {
    return CreateMaybeMessage<notifyAVStream_fullChannelInfo>(NULL);
  }

  notifyAVStream_fullChannelInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyAVStream_fullChannelInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyAVStream_fullChannelInfo& from);
  void MergeFrom(const notifyAVStream_fullChannelInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyAVStream_fullChannelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string localResAccStr = 3;
  void clear_localresaccstr();
  static const int kLocalResAccStrFieldNumber = 3;
  const ::std::string& localresaccstr() const;
  void set_localresaccstr(const ::std::string& value);
  #if LANG_CXX11
  void set_localresaccstr(::std::string&& value);
  #endif
  void set_localresaccstr(const char* value);
  void set_localresaccstr(const char* value, size_t size);
  ::std::string* mutable_localresaccstr();
  ::std::string* release_localresaccstr();
  void set_allocated_localresaccstr(::std::string* localresaccstr);

  // string channelDescription = 4;
  void clear_channeldescription();
  static const int kChannelDescriptionFieldNumber = 4;
  const ::std::string& channeldescription() const;
  void set_channeldescription(const ::std::string& value);
  #if LANG_CXX11
  void set_channeldescription(::std::string&& value);
  #endif
  void set_channeldescription(const char* value);
  void set_channeldescription(const char* value, size_t size);
  ::std::string* mutable_channeldescription();
  ::std::string* release_channeldescription();
  void set_allocated_channeldescription(::std::string* channeldescription);

  // string remotePass = 8;
  void clear_remotepass();
  static const int kRemotePassFieldNumber = 8;
  const ::std::string& remotepass() const;
  void set_remotepass(const ::std::string& value);
  #if LANG_CXX11
  void set_remotepass(::std::string&& value);
  #endif
  void set_remotepass(const char* value);
  void set_remotepass(const char* value, size_t size);
  ::std::string* mutable_remotepass();
  ::std::string* release_remotepass();
  void set_allocated_remotepass(::std::string* remotepass);

  // int32 devType = 1;
  void clear_devtype();
  static const int kDevTypeFieldNumber = 1;
  ::google::protobuf::int32 devtype() const;
  void set_devtype(::google::protobuf::int32 value);

  // int32 dataType = 2;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 2;
  ::google::protobuf::int32 datatype() const;
  void set_datatype(::google::protobuf::int32 value);

  // int64 remoteIP = 6;
  void clear_remoteip();
  static const int kRemoteIPFieldNumber = 6;
  ::google::protobuf::int64 remoteip() const;
  void set_remoteip(::google::protobuf::int64 value);

  // int32 bwReq = 5;
  void clear_bwreq();
  static const int kBwReqFieldNumber = 5;
  ::google::protobuf::int32 bwreq() const;
  void set_bwreq(::google::protobuf::int32 value);

  // int32 remotePort = 7;
  void clear_remoteport();
  static const int kRemotePortFieldNumber = 7;
  ::google::protobuf::int32 remoteport() const;
  void set_remoteport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyAVStream.fullChannelInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr localresaccstr_;
  ::google::protobuf::internal::ArenaStringPtr channeldescription_;
  ::google::protobuf::internal::ArenaStringPtr remotepass_;
  ::google::protobuf::int32 devtype_;
  ::google::protobuf::int32 datatype_;
  ::google::protobuf::int64 remoteip_;
  ::google::protobuf::int32 bwreq_;
  ::google::protobuf::int32 remoteport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyAVStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyAVStream) */ {
 public:
  notifyAVStream();
  virtual ~notifyAVStream();

  notifyAVStream(const notifyAVStream& from);

  inline notifyAVStream& operator=(const notifyAVStream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyAVStream(notifyAVStream&& from) noexcept
    : notifyAVStream() {
    *this = ::std::move(from);
  }

  inline notifyAVStream& operator=(notifyAVStream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyAVStream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyAVStream* internal_default_instance() {
    return reinterpret_cast<const notifyAVStream*>(
               &_notifyAVStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(notifyAVStream* other);
  friend void swap(notifyAVStream& a, notifyAVStream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyAVStream* New() const final {
    return CreateMaybeMessage<notifyAVStream>(NULL);
  }

  notifyAVStream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyAVStream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyAVStream& from);
  void MergeFrom(const notifyAVStream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyAVStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef notifyAVStream_fullChannelInfo fullChannelInfo;

  // accessors -------------------------------------------------------

  // repeated .DDRCommProto.notifyAVStream.fullChannelInfo robotMonitorChannels = 2;
  int robotmonitorchannels_size() const;
  void clear_robotmonitorchannels();
  static const int kRobotMonitorChannelsFieldNumber = 2;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* mutable_robotmonitorchannels(int index);
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >*
      mutable_robotmonitorchannels();
  const ::DDRCommProto::notifyAVStream_fullChannelInfo& robotmonitorchannels(int index) const;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* add_robotmonitorchannels();
  const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >&
      robotmonitorchannels() const;

  // .DDRCommProto.notifyAVStream.fullChannelInfo reservedChannel = 1;
  bool has_reservedchannel() const;
  void clear_reservedchannel();
  static const int kReservedChannelFieldNumber = 1;
  private:
  const ::DDRCommProto::notifyAVStream_fullChannelInfo& _internal_reservedchannel() const;
  public:
  const ::DDRCommProto::notifyAVStream_fullChannelInfo& reservedchannel() const;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* release_reservedchannel();
  ::DDRCommProto::notifyAVStream_fullChannelInfo* mutable_reservedchannel();
  void set_allocated_reservedchannel(::DDRCommProto::notifyAVStream_fullChannelInfo* reservedchannel);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyAVStream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo > robotmonitorchannels_;
  ::DDRCommProto::notifyAVStream_fullChannelInfo* reservedchannel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqTalk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqTalk) */ {
 public:
  reqTalk();
  virtual ~reqTalk();

  reqTalk(const reqTalk& from);

  inline reqTalk& operator=(const reqTalk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqTalk(reqTalk&& from) noexcept
    : reqTalk() {
    *this = ::std::move(from);
  }

  inline reqTalk& operator=(reqTalk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqTalk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqTalk* internal_default_instance() {
    return reinterpret_cast<const reqTalk*>(
               &_reqTalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(reqTalk* other);
  friend void swap(reqTalk& a, reqTalk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqTalk* New() const final {
    return CreateMaybeMessage<reqTalk>(NULL);
  }

  reqTalk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqTalk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqTalk& from);
  void MergeFrom(const reqTalk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqTalk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqTalk_eCallerType eCallerType;
  static const eCallerType client =
    reqTalk_eCallerType_client;
  static const eCallerType monitor =
    reqTalk_eCallerType_monitor;
  static const eCallerType robot_LSM =
    reqTalk_eCallerType_robot_LSM;
  static inline bool eCallerType_IsValid(int value) {
    return reqTalk_eCallerType_IsValid(value);
  }
  static const eCallerType eCallerType_MIN =
    reqTalk_eCallerType_eCallerType_MIN;
  static const eCallerType eCallerType_MAX =
    reqTalk_eCallerType_eCallerType_MAX;
  static const int eCallerType_ARRAYSIZE =
    reqTalk_eCallerType_eCallerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eCallerType_descriptor() {
    return reqTalk_eCallerType_descriptor();
  }
  static inline const ::std::string& eCallerType_Name(eCallerType value) {
    return reqTalk_eCallerType_Name(value);
  }
  static inline bool eCallerType_Parse(const ::std::string& name,
      eCallerType* value) {
    return reqTalk_eCallerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .DDRCommProto.reqTalk.eCallerType callerType = 1;
  void clear_callertype();
  static const int kCallerTypeFieldNumber = 1;
  ::DDRCommProto::reqTalk_eCallerType callertype() const;
  void set_callertype(::DDRCommProto::reqTalk_eCallerType value);

  // int32 id1 = 2;
  void clear_id1();
  static const int kId1FieldNumber = 2;
  ::google::protobuf::int32 id1() const;
  void set_id1(::google::protobuf::int32 value);

  // int32 id2 = 3;
  void clear_id2();
  static const int kId2FieldNumber = 3;
  ::google::protobuf::int32 id2() const;
  void set_id2(::google::protobuf::int32 value);

  // int32 avType = 4;
  void clear_avtype();
  static const int kAvTypeFieldNumber = 4;
  ::google::protobuf::int32 avtype() const;
  void set_avtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqTalk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int callertype_;
  ::google::protobuf::int32 id1_;
  ::google::protobuf::int32 id2_;
  ::google::protobuf::int32 avtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respTalk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respTalk) */ {
 public:
  respTalk();
  virtual ~respTalk();

  respTalk(const respTalk& from);

  inline respTalk& operator=(const respTalk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respTalk(respTalk&& from) noexcept
    : respTalk() {
    *this = ::std::move(from);
  }

  inline respTalk& operator=(respTalk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respTalk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respTalk* internal_default_instance() {
    return reinterpret_cast<const respTalk*>(
               &_respTalk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(respTalk* other);
  friend void swap(respTalk& a, respTalk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respTalk* New() const final {
    return CreateMaybeMessage<respTalk>(NULL);
  }

  respTalk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respTalk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respTalk& from);
  void MergeFrom(const respTalk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respTalk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respTalk_eReceiverType eReceiverType;
  static const eReceiverType client =
    respTalk_eReceiverType_client;
  static const eReceiverType monitor =
    respTalk_eReceiverType_monitor;
  static const eReceiverType robot_LSM =
    respTalk_eReceiverType_robot_LSM;
  static inline bool eReceiverType_IsValid(int value) {
    return respTalk_eReceiverType_IsValid(value);
  }
  static const eReceiverType eReceiverType_MIN =
    respTalk_eReceiverType_eReceiverType_MIN;
  static const eReceiverType eReceiverType_MAX =
    respTalk_eReceiverType_eReceiverType_MAX;
  static const int eReceiverType_ARRAYSIZE =
    respTalk_eReceiverType_eReceiverType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eReceiverType_descriptor() {
    return respTalk_eReceiverType_descriptor();
  }
  static inline const ::std::string& eReceiverType_Name(eReceiverType value) {
    return respTalk_eReceiverType_Name(value);
  }
  static inline bool eReceiverType_Parse(const ::std::string& name,
      eReceiverType* value) {
    return respTalk_eReceiverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .DDRCommProto.respTalk.eReceiverType receiverType = 1;
  void clear_receivertype();
  static const int kReceiverTypeFieldNumber = 1;
  ::DDRCommProto::respTalk_eReceiverType receivertype() const;
  void set_receivertype(::DDRCommProto::respTalk_eReceiverType value);

  // int32 id1 = 2;
  void clear_id1();
  static const int kId1FieldNumber = 2;
  ::google::protobuf::int32 id1() const;
  void set_id1(::google::protobuf::int32 value);

  // int32 id2 = 3;
  void clear_id2();
  static const int kId2FieldNumber = 3;
  ::google::protobuf::int32 id2() const;
  void set_id2(::google::protobuf::int32 value);

  // int32 avType = 4;
  void clear_avtype();
  static const int kAvTypeFieldNumber = 4;
  ::google::protobuf::int32 avtype() const;
  void set_avtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respTalk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int receivertype_;
  ::google::protobuf::int32 id1_;
  ::google::protobuf::int32 id2_;
  ::google::protobuf::int32 avtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class cmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.cmd) */ {
 public:
  cmd();
  virtual ~cmd();

  cmd(const cmd& from);

  inline cmd& operator=(const cmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  cmd(cmd&& from) noexcept
    : cmd() {
    *this = ::std::move(from);
  }

  inline cmd& operator=(cmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const cmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const cmd* internal_default_instance() {
    return reinterpret_cast<const cmd*>(
               &_cmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(cmd* other);
  friend void swap(cmd& a, cmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline cmd* New() const final {
    return CreateMaybeMessage<cmd>(NULL);
  }

  cmd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<cmd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const cmd& from);
  void MergeFrom(const cmd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(cmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cmdMsg = 2;
  void clear_cmdmsg();
  static const int kCmdMsgFieldNumber = 2;
  const ::std::string& cmdmsg() const;
  void set_cmdmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_cmdmsg(::std::string&& value);
  #endif
  void set_cmdmsg(const char* value);
  void set_cmdmsg(const char* value, size_t size);
  ::std::string* mutable_cmdmsg();
  ::std::string* release_cmdmsg();
  void set_allocated_cmdmsg(::std::string* cmdmsg);

  // int64 cmdID = 1;
  void clear_cmdid();
  static const int kCmdIDFieldNumber = 1;
  ::google::protobuf::int64 cmdid() const;
  void set_cmdid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.cmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cmdmsg_;
  ::google::protobuf::int64 cmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respCmd) */ {
 public:
  respCmd();
  virtual ~respCmd();

  respCmd(const respCmd& from);

  inline respCmd& operator=(const respCmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respCmd(respCmd&& from) noexcept
    : respCmd() {
    *this = ::std::move(from);
  }

  inline respCmd& operator=(respCmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respCmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respCmd* internal_default_instance() {
    return reinterpret_cast<const respCmd*>(
               &_respCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(respCmd* other);
  friend void swap(respCmd& a, respCmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respCmd* New() const final {
    return CreateMaybeMessage<respCmd>(NULL);
  }

  respCmd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respCmd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respCmd& from);
  void MergeFrom(const respCmd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string respMsg = 2;
  void clear_respmsg();
  static const int kRespMsgFieldNumber = 2;
  const ::std::string& respmsg() const;
  void set_respmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_respmsg(::std::string&& value);
  #endif
  void set_respmsg(const char* value);
  void set_respmsg(const char* value, size_t size);
  ::std::string* mutable_respmsg();
  ::std::string* release_respmsg();
  void set_allocated_respmsg(::std::string* respmsg);

  // int64 cmdID = 1;
  void clear_cmdid();
  static const int kCmdIDFieldNumber = 1;
  ::google::protobuf::int64 cmdid() const;
  void set_cmdid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr respmsg_;
  ::google::protobuf::int64 cmdid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class reqFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.reqFile) */ {
 public:
  reqFile();
  virtual ~reqFile();

  reqFile(const reqFile& from);

  inline reqFile& operator=(const reqFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  reqFile(reqFile&& from) noexcept
    : reqFile() {
    *this = ::std::move(from);
  }

  inline reqFile& operator=(reqFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const reqFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const reqFile* internal_default_instance() {
    return reinterpret_cast<const reqFile*>(
               &_reqFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(reqFile* other);
  friend void swap(reqFile& a, reqFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline reqFile* New() const final {
    return CreateMaybeMessage<reqFile>(NULL);
  }

  reqFile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<reqFile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const reqFile& from);
  void MergeFrom(const reqFile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(reqFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef reqFile_eZipFormat eZipFormat;
  static const eZipFormat noZip =
    reqFile_eZipFormat_noZip;
  static const eZipFormat Zip =
    reqFile_eZipFormat_Zip;
  static inline bool eZipFormat_IsValid(int value) {
    return reqFile_eZipFormat_IsValid(value);
  }
  static const eZipFormat eZipFormat_MIN =
    reqFile_eZipFormat_eZipFormat_MIN;
  static const eZipFormat eZipFormat_MAX =
    reqFile_eZipFormat_eZipFormat_MAX;
  static const int eZipFormat_ARRAYSIZE =
    reqFile_eZipFormat_eZipFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eZipFormat_descriptor() {
    return reqFile_eZipFormat_descriptor();
  }
  static inline const ::std::string& eZipFormat_Name(eZipFormat value) {
    return reqFile_eZipFormat_Name(value);
  }
  static inline bool eZipFormat_Parse(const ::std::string& name,
      eZipFormat* value) {
    return reqFile_eZipFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string fileInqText = 2;
  void clear_fileinqtext();
  static const int kFileInqTextFieldNumber = 2;
  const ::std::string& fileinqtext() const;
  void set_fileinqtext(const ::std::string& value);
  #if LANG_CXX11
  void set_fileinqtext(::std::string&& value);
  #endif
  void set_fileinqtext(const char* value);
  void set_fileinqtext(const char* value, size_t size);
  ::std::string* mutable_fileinqtext();
  ::std::string* release_fileinqtext();
  void set_allocated_fileinqtext(::std::string* fileinqtext);

  // .DDRCommProto.reqFile.eZipFormat zipFormat = 1;
  void clear_zipformat();
  static const int kZipFormatFieldNumber = 1;
  ::DDRCommProto::reqFile_eZipFormat zipformat() const;
  void set_zipformat(::DDRCommProto::reqFile_eZipFormat value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.reqFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fileinqtext_;
  int zipformat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class respFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.respFile) */ {
 public:
  respFile();
  virtual ~respFile();

  respFile(const respFile& from);

  inline respFile& operator=(const respFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  respFile(respFile&& from) noexcept
    : respFile() {
    *this = ::std::move(from);
  }

  inline respFile& operator=(respFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const respFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const respFile* internal_default_instance() {
    return reinterpret_cast<const respFile*>(
               &_respFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(respFile* other);
  friend void swap(respFile& a, respFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline respFile* New() const final {
    return CreateMaybeMessage<respFile>(NULL);
  }

  respFile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<respFile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const respFile& from);
  void MergeFrom(const respFile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(respFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef respFile_eZipFormat eZipFormat;
  static const eZipFormat noZip =
    respFile_eZipFormat_noZip;
  static const eZipFormat Zip =
    respFile_eZipFormat_Zip;
  static inline bool eZipFormat_IsValid(int value) {
    return respFile_eZipFormat_IsValid(value);
  }
  static const eZipFormat eZipFormat_MIN =
    respFile_eZipFormat_eZipFormat_MIN;
  static const eZipFormat eZipFormat_MAX =
    respFile_eZipFormat_eZipFormat_MAX;
  static const int eZipFormat_ARRAYSIZE =
    respFile_eZipFormat_eZipFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  eZipFormat_descriptor() {
    return respFile_eZipFormat_descriptor();
  }
  static inline const ::std::string& eZipFormat_Name(eZipFormat value) {
    return respFile_eZipFormat_Name(value);
  }
  static inline bool eZipFormat_Parse(const ::std::string& name,
      eZipFormat* value) {
    return respFile_eZipFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string fileResp = 2;
  void clear_fileresp();
  static const int kFileRespFieldNumber = 2;
  const ::std::string& fileresp() const;
  void set_fileresp(const ::std::string& value);
  #if LANG_CXX11
  void set_fileresp(::std::string&& value);
  #endif
  void set_fileresp(const char* value);
  void set_fileresp(const char* value, size_t size);
  ::std::string* mutable_fileresp();
  ::std::string* release_fileresp();
  void set_allocated_fileresp(::std::string* fileresp);

  // .DDRCommProto.respFile.eZipFormat zipFormat = 1;
  void clear_zipformat();
  static const int kZipFormatFieldNumber = 1;
  ::DDRCommProto::respFile_eZipFormat zipformat() const;
  void set_zipformat(::DDRCommProto::respFile_eZipFormat value);

  // @@protoc_insertion_point(class_scope:DDRCommProto.respFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fileresp_;
  int zipformat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyStatus) */ {
 public:
  notifyStatus();
  virtual ~notifyStatus();

  notifyStatus(const notifyStatus& from);

  inline notifyStatus& operator=(const notifyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyStatus(notifyStatus&& from) noexcept
    : notifyStatus() {
    *this = ::std::move(from);
  }

  inline notifyStatus& operator=(notifyStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyStatus* internal_default_instance() {
    return reinterpret_cast<const notifyStatus*>(
               &_notifyStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(notifyStatus* other);
  friend void swap(notifyStatus& a, notifyStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyStatus* New() const final {
    return CreateMaybeMessage<notifyStatus>(NULL);
  }

  notifyStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyStatus& from);
  void MergeFrom(const notifyStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string statusMsg = 1;
  void clear_statusmsg();
  static const int kStatusMsgFieldNumber = 1;
  const ::std::string& statusmsg() const;
  void set_statusmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_statusmsg(::std::string&& value);
  #endif
  void set_statusmsg(const char* value);
  void set_statusmsg(const char* value, size_t size);
  ::std::string* mutable_statusmsg();
  ::std::string* release_statusmsg();
  void set_allocated_statusmsg(::std::string* statusmsg);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr statusmsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyAlarm) */ {
 public:
  notifyAlarm();
  virtual ~notifyAlarm();

  notifyAlarm(const notifyAlarm& from);

  inline notifyAlarm& operator=(const notifyAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyAlarm(notifyAlarm&& from) noexcept
    : notifyAlarm() {
    *this = ::std::move(from);
  }

  inline notifyAlarm& operator=(notifyAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyAlarm* internal_default_instance() {
    return reinterpret_cast<const notifyAlarm*>(
               &_notifyAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(notifyAlarm* other);
  friend void swap(notifyAlarm& a, notifyAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyAlarm* New() const final {
    return CreateMaybeMessage<notifyAlarm>(NULL);
  }

  notifyAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyAlarm& from);
  void MergeFrom(const notifyAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string alarmMsg = 1;
  void clear_alarmmsg();
  static const int kAlarmMsgFieldNumber = 1;
  const ::std::string& alarmmsg() const;
  void set_alarmmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_alarmmsg(::std::string&& value);
  #endif
  void set_alarmmsg(const char* value);
  void set_alarmmsg(const char* value, size_t size);
  ::std::string* mutable_alarmmsg();
  ::std::string* release_alarmmsg();
  void set_allocated_alarmmsg(::std::string* alarmmsg);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyAlarm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr alarmmsg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class notifyTextChat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DDRCommProto.notifyTextChat) */ {
 public:
  notifyTextChat();
  virtual ~notifyTextChat();

  notifyTextChat(const notifyTextChat& from);

  inline notifyTextChat& operator=(const notifyTextChat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  notifyTextChat(notifyTextChat&& from) noexcept
    : notifyTextChat() {
    *this = ::std::move(from);
  }

  inline notifyTextChat& operator=(notifyTextChat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const notifyTextChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const notifyTextChat* internal_default_instance() {
    return reinterpret_cast<const notifyTextChat*>(
               &_notifyTextChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(notifyTextChat* other);
  friend void swap(notifyTextChat& a, notifyTextChat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline notifyTextChat* New() const final {
    return CreateMaybeMessage<notifyTextChat>(NULL);
  }

  notifyTextChat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<notifyTextChat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const notifyTextChat& from);
  void MergeFrom(const notifyTextChat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(notifyTextChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chatText = 1;
  void clear_chattext();
  static const int kChatTextFieldNumber = 1;
  const ::std::string& chattext() const;
  void set_chattext(const ::std::string& value);
  #if LANG_CXX11
  void set_chattext(::std::string&& value);
  #endif
  void set_chattext(const char* value);
  void set_chattext(const char* value, size_t size);
  ::std::string* mutable_chattext();
  ::std::string* release_chattext();
  void set_allocated_chattext(::std::string* chattext);

  // @@protoc_insertion_point(class_scope:DDRCommProto.notifyTextChat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chattext_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_BaseCmd_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonHeader

// string bodyType = 1;
inline void CommonHeader::clear_bodytype() {
  bodytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommonHeader::bodytype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.bodyType)
  return bodytype_.GetNoArena();
}
inline void CommonHeader::set_bodytype(const ::std::string& value) {
  
  bodytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.bodyType)
}
#if LANG_CXX11
inline void CommonHeader::set_bodytype(::std::string&& value) {
  
  bodytype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.CommonHeader.bodyType)
}
#endif
inline void CommonHeader::set_bodytype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bodytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.CommonHeader.bodyType)
}
inline void CommonHeader::set_bodytype(const char* value, size_t size) {
  
  bodytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.CommonHeader.bodyType)
}
inline ::std::string* CommonHeader::mutable_bodytype() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.CommonHeader.bodyType)
  return bodytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommonHeader::release_bodytype() {
  // @@protoc_insertion_point(field_release:DDRCommProto.CommonHeader.bodyType)
  
  return bodytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommonHeader::set_allocated_bodytype(::std::string* bodytype) {
  if (bodytype != NULL) {
    
  } else {
    
  }
  bodytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bodytype);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.CommonHeader.bodyType)
}

// repeated .DDRCommProto.CommonHeader.eFlowDir flowDirection = 2;
inline int CommonHeader::flowdirection_size() const {
  return flowdirection_.size();
}
inline void CommonHeader::clear_flowdirection() {
  flowdirection_.Clear();
}
inline ::DDRCommProto::CommonHeader_eFlowDir CommonHeader::flowdirection(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.flowDirection)
  return static_cast< ::DDRCommProto::CommonHeader_eFlowDir >(flowdirection_.Get(index));
}
inline void CommonHeader::set_flowdirection(int index, ::DDRCommProto::CommonHeader_eFlowDir value) {
  flowdirection_.Set(index, value);
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.flowDirection)
}
inline void CommonHeader::add_flowdirection(::DDRCommProto::CommonHeader_eFlowDir value) {
  flowdirection_.Add(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.flowDirection)
}
inline const ::google::protobuf::RepeatedField<int>&
CommonHeader::flowdirection() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.CommonHeader.flowDirection)
  return flowdirection_;
}
inline ::google::protobuf::RepeatedField<int>*
CommonHeader::mutable_flowdirection() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.CommonHeader.flowDirection)
  return &flowdirection_;
}

// repeated .DDRCommProto.CommonHeader.eDestType destType = 3;
inline int CommonHeader::desttype_size() const {
  return desttype_.size();
}
inline void CommonHeader::clear_desttype() {
  desttype_.Clear();
}
inline ::DDRCommProto::CommonHeader_eDestType CommonHeader::desttype(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.destType)
  return static_cast< ::DDRCommProto::CommonHeader_eDestType >(desttype_.Get(index));
}
inline void CommonHeader::set_desttype(int index, ::DDRCommProto::CommonHeader_eDestType value) {
  desttype_.Set(index, value);
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.destType)
}
inline void CommonHeader::add_desttype(::DDRCommProto::CommonHeader_eDestType value) {
  desttype_.Add(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.destType)
}
inline const ::google::protobuf::RepeatedField<int>&
CommonHeader::desttype() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.CommonHeader.destType)
  return desttype_;
}
inline ::google::protobuf::RepeatedField<int>*
CommonHeader::mutable_desttype() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.CommonHeader.destType)
  return &desttype_;
}

// repeated string destInfo = 4;
inline int CommonHeader::destinfo_size() const {
  return destinfo_.size();
}
inline void CommonHeader::clear_destinfo() {
  destinfo_.Clear();
}
inline const ::std::string& CommonHeader::destinfo(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.CommonHeader.destInfo)
  return destinfo_.Get(index);
}
inline ::std::string* CommonHeader::mutable_destinfo(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.CommonHeader.destInfo)
  return destinfo_.Mutable(index);
}
inline void CommonHeader::set_destinfo(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.destInfo)
  destinfo_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CommonHeader::set_destinfo(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.CommonHeader.destInfo)
  destinfo_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CommonHeader::set_destinfo(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  destinfo_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.CommonHeader.destInfo)
}
inline void CommonHeader::set_destinfo(int index, const char* value, size_t size) {
  destinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.CommonHeader.destInfo)
}
inline ::std::string* CommonHeader::add_destinfo() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.CommonHeader.destInfo)
  return destinfo_.Add();
}
inline void CommonHeader::add_destinfo(const ::std::string& value) {
  destinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.destInfo)
}
#if LANG_CXX11
inline void CommonHeader::add_destinfo(::std::string&& value) {
  destinfo_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.CommonHeader.destInfo)
}
#endif
inline void CommonHeader::add_destinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  destinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.CommonHeader.destInfo)
}
inline void CommonHeader::add_destinfo(const char* value, size_t size) {
  destinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.CommonHeader.destInfo)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommonHeader::destinfo() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.CommonHeader.destInfo)
  return destinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommonHeader::mutable_destinfo() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.CommonHeader.destInfo)
  return &destinfo_;
}

// -------------------------------------------------------------------

// heartBeat

// string whatever = 1;
inline void heartBeat::clear_whatever() {
  whatever_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& heartBeat::whatever() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.heartBeat.whatever)
  return whatever_.GetNoArena();
}
inline void heartBeat::set_whatever(const ::std::string& value) {
  
  whatever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.heartBeat.whatever)
}
#if LANG_CXX11
inline void heartBeat::set_whatever(::std::string&& value) {
  
  whatever_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.heartBeat.whatever)
}
#endif
inline void heartBeat::set_whatever(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  whatever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.heartBeat.whatever)
}
inline void heartBeat::set_whatever(const char* value, size_t size) {
  
  whatever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.heartBeat.whatever)
}
inline ::std::string* heartBeat::mutable_whatever() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.heartBeat.whatever)
  return whatever_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* heartBeat::release_whatever() {
  // @@protoc_insertion_point(field_release:DDRCommProto.heartBeat.whatever)
  
  return whatever_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void heartBeat::set_allocated_whatever(::std::string* whatever) {
  if (whatever != NULL) {
    
  } else {
    
  }
  whatever_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), whatever);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.heartBeat.whatever)
}

// -------------------------------------------------------------------

// bcLSAddr

// string name = 1;
inline void bcLSAddr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& bcLSAddr::name() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.name)
  return name_.GetNoArena();
}
inline void bcLSAddr::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.name)
}
#if LANG_CXX11
inline void bcLSAddr::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.bcLSAddr.name)
}
#endif
inline void bcLSAddr::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.bcLSAddr.name)
}
inline void bcLSAddr::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.bcLSAddr.name)
}
inline ::std::string* bcLSAddr::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.bcLSAddr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* bcLSAddr::release_name() {
  // @@protoc_insertion_point(field_release:DDRCommProto.bcLSAddr.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void bcLSAddr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.bcLSAddr.name)
}

// repeated string ips = 2;
inline int bcLSAddr::ips_size() const {
  return ips_.size();
}
inline void bcLSAddr::clear_ips() {
  ips_.Clear();
}
inline const ::std::string& bcLSAddr::ips(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.ips)
  return ips_.Get(index);
}
inline ::std::string* bcLSAddr::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.bcLSAddr.ips)
  return ips_.Mutable(index);
}
inline void bcLSAddr::set_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.ips)
  ips_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void bcLSAddr::set_ips(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.ips)
  ips_.Mutable(index)->assign(std::move(value));
}
#endif
inline void bcLSAddr::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.bcLSAddr.ips)
}
inline void bcLSAddr::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.bcLSAddr.ips)
}
inline ::std::string* bcLSAddr::add_ips() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.bcLSAddr.ips)
  return ips_.Add();
}
inline void bcLSAddr::add_ips(const ::std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.bcLSAddr.ips)
}
#if LANG_CXX11
inline void bcLSAddr::add_ips(::std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.bcLSAddr.ips)
}
#endif
inline void bcLSAddr::add_ips(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.bcLSAddr.ips)
}
inline void bcLSAddr::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.bcLSAddr.ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
bcLSAddr::ips() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.bcLSAddr.ips)
  return ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
bcLSAddr::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.bcLSAddr.ips)
  return &ips_;
}

// int32 port = 3;
inline void bcLSAddr::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 bcLSAddr::port() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.bcLSAddr.port)
  return port_;
}
inline void bcLSAddr::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.bcLSAddr.port)
}

// -------------------------------------------------------------------

// reqLogin_msgAVStreamReq

// int32 avType = 1;
inline void reqLogin_msgAVStreamReq::clear_avtype() {
  avtype_ = 0;
}
inline ::google::protobuf::int32 reqLogin_msgAVStreamReq::avtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.msgAVStreamReq.avType)
  return avtype_;
}
inline void reqLogin_msgAVStreamReq::set_avtype(::google::protobuf::int32 value) {
  
  avtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.msgAVStreamReq.avType)
}

// string chName = 2;
inline void reqLogin_msgAVStreamReq::clear_chname() {
  chname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin_msgAVStreamReq::chname() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.msgAVStreamReq.chName)
  return chname_.GetNoArena();
}
inline void reqLogin_msgAVStreamReq::set_chname(const ::std::string& value) {
  
  chname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
#if LANG_CXX11
inline void reqLogin_msgAVStreamReq::set_chname(::std::string&& value) {
  
  chname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
#endif
inline void reqLogin_msgAVStreamReq::set_chname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
inline void reqLogin_msgAVStreamReq::set_chname(const char* value, size_t size) {
  
  chname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}
inline ::std::string* reqLogin_msgAVStreamReq::mutable_chname() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.msgAVStreamReq.chName)
  return chname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin_msgAVStreamReq::release_chname() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.msgAVStreamReq.chName)
  
  return chname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin_msgAVStreamReq::set_allocated_chname(::std::string* chname) {
  if (chname != NULL) {
    
  } else {
    
  }
  chname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chname);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.msgAVStreamReq.chName)
}

// int32 bandwidthReq = 3;
inline void reqLogin_msgAVStreamReq::clear_bandwidthreq() {
  bandwidthreq_ = 0;
}
inline ::google::protobuf::int32 reqLogin_msgAVStreamReq::bandwidthreq() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.msgAVStreamReq.bandwidthReq)
  return bandwidthreq_;
}
inline void reqLogin_msgAVStreamReq::set_bandwidthreq(::google::protobuf::int32 value) {
  
  bandwidthreq_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.msgAVStreamReq.bandwidthReq)
}

// -------------------------------------------------------------------

// reqLogin

// .DDRCommProto.reqLogin.eCltType type = 1;
inline void reqLogin::clear_type() {
  type_ = 0;
}
inline ::DDRCommProto::reqLogin_eCltType reqLogin::type() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.type)
  return static_cast< ::DDRCommProto::reqLogin_eCltType >(type_);
}
inline void reqLogin::set_type(::DDRCommProto::reqLogin_eCltType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.type)
}

// string username = 2;
inline void reqLogin::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin::username() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.username)
  return username_.GetNoArena();
}
inline void reqLogin::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.username)
}
#if LANG_CXX11
inline void reqLogin::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.username)
}
#endif
inline void reqLogin::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.username)
}
inline void reqLogin::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.username)
}
inline ::std::string* reqLogin::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin::release_username() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.username)
}

// string robotID = 3;
inline void reqLogin::clear_robotid() {
  robotid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin::robotid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.robotID)
  return robotid_.GetNoArena();
}
inline void reqLogin::set_robotid(const ::std::string& value) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.robotID)
}
#if LANG_CXX11
inline void reqLogin::set_robotid(::std::string&& value) {
  
  robotid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.robotID)
}
#endif
inline void reqLogin::set_robotid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.robotID)
}
inline void reqLogin::set_robotid(const char* value, size_t size) {
  
  robotid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.robotID)
}
inline ::std::string* reqLogin::mutable_robotid() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.robotID)
  return robotid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin::release_robotid() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.robotID)
  
  return robotid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin::set_allocated_robotid(::std::string* robotid) {
  if (robotid != NULL) {
    
  } else {
    
  }
  robotid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotid);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.robotID)
}

// string robotPWD = 4;
inline void reqLogin::clear_robotpwd() {
  robotpwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqLogin::robotpwd() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.robotPWD)
  return robotpwd_.GetNoArena();
}
inline void reqLogin::set_robotpwd(const ::std::string& value) {
  
  robotpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.robotPWD)
}
#if LANG_CXX11
inline void reqLogin::set_robotpwd(::std::string&& value) {
  
  robotpwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqLogin.robotPWD)
}
#endif
inline void reqLogin::set_robotpwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  robotpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqLogin.robotPWD)
}
inline void reqLogin::set_robotpwd(const char* value, size_t size) {
  
  robotpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqLogin.robotPWD)
}
inline ::std::string* reqLogin::mutable_robotpwd() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.robotPWD)
  return robotpwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqLogin::release_robotpwd() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqLogin.robotPWD)
  
  return robotpwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqLogin::set_allocated_robotpwd(::std::string* robotpwd) {
  if (robotpwd != NULL) {
    
  } else {
    
  }
  robotpwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robotpwd);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqLogin.robotPWD)
}

// int32 cltOpLv = 5;
inline void reqLogin::clear_cltoplv() {
  cltoplv_ = 0;
}
inline ::google::protobuf::int32 reqLogin::cltoplv() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.cltOpLv)
  return cltoplv_;
}
inline void reqLogin::set_cltoplv(::google::protobuf::int32 value) {
  
  cltoplv_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.cltOpLv)
}

// int32 UID = 6;
inline void reqLogin::clear_uid() {
  uid_ = 0;
}
inline ::google::protobuf::int32 reqLogin::uid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.UID)
  return uid_;
}
inline void reqLogin::set_uid(::google::protobuf::int32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqLogin.UID)
}

// repeated .DDRCommProto.reqLogin.msgAVStreamReq avStreamReq = 7;
inline int reqLogin::avstreamreq_size() const {
  return avstreamreq_.size();
}
inline void reqLogin::clear_avstreamreq() {
  avstreamreq_.Clear();
}
inline ::DDRCommProto::reqLogin_msgAVStreamReq* reqLogin::mutable_avstreamreq(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >*
reqLogin::mutable_avstreamreq() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.reqLogin.avStreamReq)
  return &avstreamreq_;
}
inline const ::DDRCommProto::reqLogin_msgAVStreamReq& reqLogin::avstreamreq(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_.Get(index);
}
inline ::DDRCommProto::reqLogin_msgAVStreamReq* reqLogin::add_avstreamreq() {
  // @@protoc_insertion_point(field_add:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::reqLogin_msgAVStreamReq >&
reqLogin::avstreamreq() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.reqLogin.avStreamReq)
  return avstreamreq_;
}

// -------------------------------------------------------------------

// respLogin

// .DDRCommProto.respLogin.eLoginRetCode retcode = 1;
inline void respLogin::clear_retcode() {
  retcode_ = 0;
}
inline ::DDRCommProto::respLogin_eLoginRetCode respLogin::retcode() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respLogin.retcode)
  return static_cast< ::DDRCommProto::respLogin_eLoginRetCode >(retcode_);
}
inline void respLogin::set_retcode(::DDRCommProto::respLogin_eLoginRetCode value) {
  
  retcode_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respLogin.retcode)
}

// .DDRCommProto.respLogin.eCltType yourRole = 2;
inline void respLogin::clear_yourrole() {
  yourrole_ = 0;
}
inline ::DDRCommProto::respLogin_eCltType respLogin::yourrole() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respLogin.yourRole)
  return static_cast< ::DDRCommProto::respLogin_eCltType >(yourrole_);
}
inline void respLogin::set_yourrole(::DDRCommProto::respLogin_eCltType value) {
  
  yourrole_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respLogin.yourRole)
}

// int32 UID = 3;
inline void respLogin::clear_uid() {
  uid_ = 0;
}
inline ::google::protobuf::int32 respLogin::uid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respLogin.UID)
  return uid_;
}
inline void respLogin::set_uid(::google::protobuf::int32 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respLogin.UID)
}

// -------------------------------------------------------------------

// notifyTerminalAccess

// int32 bRRConnected2RS = 1;
inline void notifyTerminalAccess::clear_brrconnected2rs() {
  brrconnected2rs_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::brrconnected2rs() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.bRRConnected2RS)
  return brrconnected2rs_;
}
inline void notifyTerminalAccess::set_brrconnected2rs(::google::protobuf::int32 value) {
  
  brrconnected2rs_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.bRRConnected2RS)
}

// int32 bOp = 2;
inline void notifyTerminalAccess::clear_bop() {
  bop_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::bop() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.bOp)
  return bop_;
}
inline void notifyTerminalAccess::set_bop(::google::protobuf::int32 value) {
  
  bop_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.bOp)
}

// int32 nMonitors = 3;
inline void notifyTerminalAccess::clear_nmonitors() {
  nmonitors_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::nmonitors() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.nMonitors)
  return nmonitors_;
}
inline void notifyTerminalAccess::set_nmonitors(::google::protobuf::int32 value) {
  
  nmonitors_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nMonitors)
}

// int32 nClients = 4;
inline void notifyTerminalAccess::clear_nclients() {
  nclients_ = 0;
}
inline ::google::protobuf::int32 notifyTerminalAccess::nclients() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.nClients)
  return nclients_;
}
inline void notifyTerminalAccess::set_nclients(::google::protobuf::int32 value) {
  
  nclients_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nClients)
}

// repeated string nameLSMs = 5;
inline int notifyTerminalAccess::namelsms_size() const {
  return namelsms_.size();
}
inline void notifyTerminalAccess::clear_namelsms() {
  namelsms_.Clear();
}
inline const ::std::string& notifyTerminalAccess::namelsms(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_.Get(index);
}
inline ::std::string* notifyTerminalAccess::mutable_namelsms(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_.Mutable(index);
}
inline void notifyTerminalAccess::set_namelsms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nameLSMs)
  namelsms_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void notifyTerminalAccess::set_namelsms(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTerminalAccess.nameLSMs)
  namelsms_.Mutable(index)->assign(std::move(value));
}
#endif
inline void notifyTerminalAccess::set_namelsms(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  namelsms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline void notifyTerminalAccess::set_namelsms(int index, const char* value, size_t size) {
  namelsms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline ::std::string* notifyTerminalAccess::add_namelsms() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_.Add();
}
inline void notifyTerminalAccess::add_namelsms(const ::std::string& value) {
  namelsms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
#if LANG_CXX11
inline void notifyTerminalAccess::add_namelsms(::std::string&& value) {
  namelsms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
#endif
inline void notifyTerminalAccess::add_namelsms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  namelsms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline void notifyTerminalAccess::add_namelsms(const char* value, size_t size) {
  namelsms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.notifyTerminalAccess.nameLSMs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
notifyTerminalAccess::namelsms() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return namelsms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
notifyTerminalAccess::mutable_namelsms() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.notifyTerminalAccess.nameLSMs)
  return &namelsms_;
}

// -------------------------------------------------------------------

// notifySerAccess

// int32 nClients = 1;
inline void notifySerAccess::clear_nclients() {
  nclients_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::nclients() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.nClients)
  return nclients_;
}
inline void notifySerAccess::set_nclients(::google::protobuf::int32 value) {
  
  nclients_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.nClients)
}

// int32 cTopOpLv = 2;
inline void notifySerAccess::clear_ctopoplv() {
  ctopoplv_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::ctopoplv() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.cTopOpLv)
  return ctopoplv_;
}
inline void notifySerAccess::set_ctopoplv(::google::protobuf::int32 value) {
  
  ctopoplv_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.cTopOpLv)
}

// int64 cTopOpTime = 3;
inline void notifySerAccess::clear_ctopoptime() {
  ctopoptime_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 notifySerAccess::ctopoptime() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.cTopOpTime)
  return ctopoptime_;
}
inline void notifySerAccess::set_ctopoptime(::google::protobuf::int64 value) {
  
  ctopoptime_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.cTopOpTime)
}

// int32 nMonitors = 4;
inline void notifySerAccess::clear_nmonitors() {
  nmonitors_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::nmonitors() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.nMonitors)
  return nmonitors_;
}
inline void notifySerAccess::set_nmonitors(::google::protobuf::int32 value) {
  
  nmonitors_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.nMonitors)
}

// int32 mTopOpLv = 5;
inline void notifySerAccess::clear_mtopoplv() {
  mtopoplv_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::mtopoplv() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.mTopOpLv)
  return mtopoplv_;
}
inline void notifySerAccess::set_mtopoplv(::google::protobuf::int32 value) {
  
  mtopoplv_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.mTopOpLv)
}

// int32 mTopOpTime = 6;
inline void notifySerAccess::clear_mtopoptime() {
  mtopoptime_ = 0;
}
inline ::google::protobuf::int32 notifySerAccess::mtopoptime() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.mTopOpTime)
  return mtopoptime_;
}
inline void notifySerAccess::set_mtopoptime(::google::protobuf::int32 value) {
  
  mtopoptime_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.mTopOpTime)
}

// repeated string namesLSM = 7;
inline int notifySerAccess::nameslsm_size() const {
  return nameslsm_.size();
}
inline void notifySerAccess::clear_nameslsm() {
  nameslsm_.Clear();
}
inline const ::std::string& notifySerAccess::nameslsm(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_.Get(index);
}
inline ::std::string* notifySerAccess::mutable_nameslsm(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_.Mutable(index);
}
inline void notifySerAccess::set_nameslsm(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.namesLSM)
  nameslsm_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void notifySerAccess::set_nameslsm(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DDRCommProto.notifySerAccess.namesLSM)
  nameslsm_.Mutable(index)->assign(std::move(value));
}
#endif
inline void notifySerAccess::set_nameslsm(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nameslsm_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifySerAccess.namesLSM)
}
inline void notifySerAccess::set_nameslsm(int index, const char* value, size_t size) {
  nameslsm_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifySerAccess.namesLSM)
}
inline ::std::string* notifySerAccess::add_nameslsm() {
  // @@protoc_insertion_point(field_add_mutable:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_.Add();
}
inline void notifySerAccess::add_nameslsm(const ::std::string& value) {
  nameslsm_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DDRCommProto.notifySerAccess.namesLSM)
}
#if LANG_CXX11
inline void notifySerAccess::add_nameslsm(::std::string&& value) {
  nameslsm_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DDRCommProto.notifySerAccess.namesLSM)
}
#endif
inline void notifySerAccess::add_nameslsm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nameslsm_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DDRCommProto.notifySerAccess.namesLSM)
}
inline void notifySerAccess::add_nameslsm(const char* value, size_t size) {
  nameslsm_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DDRCommProto.notifySerAccess.namesLSM)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
notifySerAccess::nameslsm() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.notifySerAccess.namesLSM)
  return nameslsm_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
notifySerAccess::mutable_nameslsm() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.notifySerAccess.namesLSM)
  return &nameslsm_;
}

// -------------------------------------------------------------------

// notifyAVStream_fullChannelInfo

// int32 devType = 1;
inline void notifyAVStream_fullChannelInfo::clear_devtype() {
  devtype_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::devtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.devType)
  return devtype_;
}
inline void notifyAVStream_fullChannelInfo::set_devtype(::google::protobuf::int32 value) {
  
  devtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.devType)
}

// int32 dataType = 2;
inline void notifyAVStream_fullChannelInfo::clear_datatype() {
  datatype_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::datatype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.dataType)
  return datatype_;
}
inline void notifyAVStream_fullChannelInfo::set_datatype(::google::protobuf::int32 value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.dataType)
}

// string localResAccStr = 3;
inline void notifyAVStream_fullChannelInfo::clear_localresaccstr() {
  localresaccstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAVStream_fullChannelInfo::localresaccstr() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
  return localresaccstr_.GetNoArena();
}
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(const ::std::string& value) {
  
  localresaccstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
#if LANG_CXX11
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(::std::string&& value) {
  
  localresaccstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
#endif
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  localresaccstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
inline void notifyAVStream_fullChannelInfo::set_localresaccstr(const char* value, size_t size) {
  
  localresaccstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}
inline ::std::string* notifyAVStream_fullChannelInfo::mutable_localresaccstr() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
  return localresaccstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAVStream_fullChannelInfo::release_localresaccstr() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
  
  return localresaccstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAVStream_fullChannelInfo::set_allocated_localresaccstr(::std::string* localresaccstr) {
  if (localresaccstr != NULL) {
    
  } else {
    
  }
  localresaccstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), localresaccstr);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.fullChannelInfo.localResAccStr)
}

// string channelDescription = 4;
inline void notifyAVStream_fullChannelInfo::clear_channeldescription() {
  channeldescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAVStream_fullChannelInfo::channeldescription() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
  return channeldescription_.GetNoArena();
}
inline void notifyAVStream_fullChannelInfo::set_channeldescription(const ::std::string& value) {
  
  channeldescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
#if LANG_CXX11
inline void notifyAVStream_fullChannelInfo::set_channeldescription(::std::string&& value) {
  
  channeldescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
#endif
inline void notifyAVStream_fullChannelInfo::set_channeldescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  channeldescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
inline void notifyAVStream_fullChannelInfo::set_channeldescription(const char* value, size_t size) {
  
  channeldescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}
inline ::std::string* notifyAVStream_fullChannelInfo::mutable_channeldescription() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
  return channeldescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAVStream_fullChannelInfo::release_channeldescription() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
  
  return channeldescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAVStream_fullChannelInfo::set_allocated_channeldescription(::std::string* channeldescription) {
  if (channeldescription != NULL) {
    
  } else {
    
  }
  channeldescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channeldescription);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.fullChannelInfo.channelDescription)
}

// int32 bwReq = 5;
inline void notifyAVStream_fullChannelInfo::clear_bwreq() {
  bwreq_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::bwreq() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.bwReq)
  return bwreq_;
}
inline void notifyAVStream_fullChannelInfo::set_bwreq(::google::protobuf::int32 value) {
  
  bwreq_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.bwReq)
}

// int64 remoteIP = 6;
inline void notifyAVStream_fullChannelInfo::clear_remoteip() {
  remoteip_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 notifyAVStream_fullChannelInfo::remoteip() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.remoteIP)
  return remoteip_;
}
inline void notifyAVStream_fullChannelInfo::set_remoteip(::google::protobuf::int64 value) {
  
  remoteip_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.remoteIP)
}

// int32 remotePort = 7;
inline void notifyAVStream_fullChannelInfo::clear_remoteport() {
  remoteport_ = 0;
}
inline ::google::protobuf::int32 notifyAVStream_fullChannelInfo::remoteport() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.remotePort)
  return remoteport_;
}
inline void notifyAVStream_fullChannelInfo::set_remoteport(::google::protobuf::int32 value) {
  
  remoteport_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.remotePort)
}

// string remotePass = 8;
inline void notifyAVStream_fullChannelInfo::clear_remotepass() {
  remotepass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAVStream_fullChannelInfo::remotepass() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
  return remotepass_.GetNoArena();
}
inline void notifyAVStream_fullChannelInfo::set_remotepass(const ::std::string& value) {
  
  remotepass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
#if LANG_CXX11
inline void notifyAVStream_fullChannelInfo::set_remotepass(::std::string&& value) {
  
  remotepass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
#endif
inline void notifyAVStream_fullChannelInfo::set_remotepass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remotepass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
inline void notifyAVStream_fullChannelInfo::set_remotepass(const char* value, size_t size) {
  
  remotepass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}
inline ::std::string* notifyAVStream_fullChannelInfo::mutable_remotepass() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
  return remotepass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAVStream_fullChannelInfo::release_remotepass() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
  
  return remotepass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAVStream_fullChannelInfo::set_allocated_remotepass(::std::string* remotepass) {
  if (remotepass != NULL) {
    
  } else {
    
  }
  remotepass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remotepass);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.fullChannelInfo.remotePass)
}

// -------------------------------------------------------------------

// notifyAVStream

// .DDRCommProto.notifyAVStream.fullChannelInfo reservedChannel = 1;
inline bool notifyAVStream::has_reservedchannel() const {
  return this != internal_default_instance() && reservedchannel_ != NULL;
}
inline void notifyAVStream::clear_reservedchannel() {
  if (GetArenaNoVirtual() == NULL && reservedchannel_ != NULL) {
    delete reservedchannel_;
  }
  reservedchannel_ = NULL;
}
inline const ::DDRCommProto::notifyAVStream_fullChannelInfo& notifyAVStream::_internal_reservedchannel() const {
  return *reservedchannel_;
}
inline const ::DDRCommProto::notifyAVStream_fullChannelInfo& notifyAVStream::reservedchannel() const {
  const ::DDRCommProto::notifyAVStream_fullChannelInfo* p = reservedchannel_;
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.reservedChannel)
  return p != NULL ? *p : *reinterpret_cast<const ::DDRCommProto::notifyAVStream_fullChannelInfo*>(
      &::DDRCommProto::_notifyAVStream_fullChannelInfo_default_instance_);
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::release_reservedchannel() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAVStream.reservedChannel)
  
  ::DDRCommProto::notifyAVStream_fullChannelInfo* temp = reservedchannel_;
  reservedchannel_ = NULL;
  return temp;
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::mutable_reservedchannel() {
  
  if (reservedchannel_ == NULL) {
    auto* p = CreateMaybeMessage<::DDRCommProto::notifyAVStream_fullChannelInfo>(GetArenaNoVirtual());
    reservedchannel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.reservedChannel)
  return reservedchannel_;
}
inline void notifyAVStream::set_allocated_reservedchannel(::DDRCommProto::notifyAVStream_fullChannelInfo* reservedchannel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reservedchannel_;
  }
  if (reservedchannel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reservedchannel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reservedchannel, submessage_arena);
    }
    
  } else {
    
  }
  reservedchannel_ = reservedchannel;
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAVStream.reservedChannel)
}

// repeated .DDRCommProto.notifyAVStream.fullChannelInfo robotMonitorChannels = 2;
inline int notifyAVStream::robotmonitorchannels_size() const {
  return robotmonitorchannels_.size();
}
inline void notifyAVStream::clear_robotmonitorchannels() {
  robotmonitorchannels_.Clear();
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::mutable_robotmonitorchannels(int index) {
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >*
notifyAVStream::mutable_robotmonitorchannels() {
  // @@protoc_insertion_point(field_mutable_list:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return &robotmonitorchannels_;
}
inline const ::DDRCommProto::notifyAVStream_fullChannelInfo& notifyAVStream::robotmonitorchannels(int index) const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_.Get(index);
}
inline ::DDRCommProto::notifyAVStream_fullChannelInfo* notifyAVStream::add_robotmonitorchannels() {
  // @@protoc_insertion_point(field_add:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DDRCommProto::notifyAVStream_fullChannelInfo >&
notifyAVStream::robotmonitorchannels() const {
  // @@protoc_insertion_point(field_list:DDRCommProto.notifyAVStream.robotMonitorChannels)
  return robotmonitorchannels_;
}

// -------------------------------------------------------------------

// reqTalk

// .DDRCommProto.reqTalk.eCallerType callerType = 1;
inline void reqTalk::clear_callertype() {
  callertype_ = 0;
}
inline ::DDRCommProto::reqTalk_eCallerType reqTalk::callertype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.callerType)
  return static_cast< ::DDRCommProto::reqTalk_eCallerType >(callertype_);
}
inline void reqTalk::set_callertype(::DDRCommProto::reqTalk_eCallerType value) {
  
  callertype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.callerType)
}

// int32 id1 = 2;
inline void reqTalk::clear_id1() {
  id1_ = 0;
}
inline ::google::protobuf::int32 reqTalk::id1() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.id1)
  return id1_;
}
inline void reqTalk::set_id1(::google::protobuf::int32 value) {
  
  id1_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.id1)
}

// int32 id2 = 3;
inline void reqTalk::clear_id2() {
  id2_ = 0;
}
inline ::google::protobuf::int32 reqTalk::id2() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.id2)
  return id2_;
}
inline void reqTalk::set_id2(::google::protobuf::int32 value) {
  
  id2_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.id2)
}

// int32 avType = 4;
inline void reqTalk::clear_avtype() {
  avtype_ = 0;
}
inline ::google::protobuf::int32 reqTalk::avtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqTalk.avType)
  return avtype_;
}
inline void reqTalk::set_avtype(::google::protobuf::int32 value) {
  
  avtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqTalk.avType)
}

// -------------------------------------------------------------------

// respTalk

// .DDRCommProto.respTalk.eReceiverType receiverType = 1;
inline void respTalk::clear_receivertype() {
  receivertype_ = 0;
}
inline ::DDRCommProto::respTalk_eReceiverType respTalk::receivertype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.receiverType)
  return static_cast< ::DDRCommProto::respTalk_eReceiverType >(receivertype_);
}
inline void respTalk::set_receivertype(::DDRCommProto::respTalk_eReceiverType value) {
  
  receivertype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.receiverType)
}

// int32 id1 = 2;
inline void respTalk::clear_id1() {
  id1_ = 0;
}
inline ::google::protobuf::int32 respTalk::id1() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.id1)
  return id1_;
}
inline void respTalk::set_id1(::google::protobuf::int32 value) {
  
  id1_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.id1)
}

// int32 id2 = 3;
inline void respTalk::clear_id2() {
  id2_ = 0;
}
inline ::google::protobuf::int32 respTalk::id2() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.id2)
  return id2_;
}
inline void respTalk::set_id2(::google::protobuf::int32 value) {
  
  id2_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.id2)
}

// int32 avType = 4;
inline void respTalk::clear_avtype() {
  avtype_ = 0;
}
inline ::google::protobuf::int32 respTalk::avtype() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respTalk.avType)
  return avtype_;
}
inline void respTalk::set_avtype(::google::protobuf::int32 value) {
  
  avtype_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respTalk.avType)
}

// -------------------------------------------------------------------

// cmd

// int64 cmdID = 1;
inline void cmd::clear_cmdid() {
  cmdid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 cmd::cmdid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.cmd.cmdID)
  return cmdid_;
}
inline void cmd::set_cmdid(::google::protobuf::int64 value) {
  
  cmdid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.cmd.cmdID)
}

// string cmdMsg = 2;
inline void cmd::clear_cmdmsg() {
  cmdmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& cmd::cmdmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.cmd.cmdMsg)
  return cmdmsg_.GetNoArena();
}
inline void cmd::set_cmdmsg(const ::std::string& value) {
  
  cmdmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.cmd.cmdMsg)
}
#if LANG_CXX11
inline void cmd::set_cmdmsg(::std::string&& value) {
  
  cmdmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.cmd.cmdMsg)
}
#endif
inline void cmd::set_cmdmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cmdmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.cmd.cmdMsg)
}
inline void cmd::set_cmdmsg(const char* value, size_t size) {
  
  cmdmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.cmd.cmdMsg)
}
inline ::std::string* cmd::mutable_cmdmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.cmd.cmdMsg)
  return cmdmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* cmd::release_cmdmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.cmd.cmdMsg)
  
  return cmdmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void cmd::set_allocated_cmdmsg(::std::string* cmdmsg) {
  if (cmdmsg != NULL) {
    
  } else {
    
  }
  cmdmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmdmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.cmd.cmdMsg)
}

// -------------------------------------------------------------------

// respCmd

// int64 cmdID = 1;
inline void respCmd::clear_cmdid() {
  cmdid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 respCmd::cmdid() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respCmd.cmdID)
  return cmdid_;
}
inline void respCmd::set_cmdid(::google::protobuf::int64 value) {
  
  cmdid_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respCmd.cmdID)
}

// string respMsg = 2;
inline void respCmd::clear_respmsg() {
  respmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& respCmd::respmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respCmd.respMsg)
  return respmsg_.GetNoArena();
}
inline void respCmd::set_respmsg(const ::std::string& value) {
  
  respmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.respCmd.respMsg)
}
#if LANG_CXX11
inline void respCmd::set_respmsg(::std::string&& value) {
  
  respmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.respCmd.respMsg)
}
#endif
inline void respCmd::set_respmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  respmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respCmd.respMsg)
}
inline void respCmd::set_respmsg(const char* value, size_t size) {
  
  respmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respCmd.respMsg)
}
inline ::std::string* respCmd::mutable_respmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respCmd.respMsg)
  return respmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* respCmd::release_respmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.respCmd.respMsg)
  
  return respmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void respCmd::set_allocated_respmsg(::std::string* respmsg) {
  if (respmsg != NULL) {
    
  } else {
    
  }
  respmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), respmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.respCmd.respMsg)
}

// -------------------------------------------------------------------

// reqFile

// .DDRCommProto.reqFile.eZipFormat zipFormat = 1;
inline void reqFile::clear_zipformat() {
  zipformat_ = 0;
}
inline ::DDRCommProto::reqFile_eZipFormat reqFile::zipformat() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFile.zipFormat)
  return static_cast< ::DDRCommProto::reqFile_eZipFormat >(zipformat_);
}
inline void reqFile::set_zipformat(::DDRCommProto::reqFile_eZipFormat value) {
  
  zipformat_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFile.zipFormat)
}

// string fileInqText = 2;
inline void reqFile::clear_fileinqtext() {
  fileinqtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& reqFile::fileinqtext() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.reqFile.fileInqText)
  return fileinqtext_.GetNoArena();
}
inline void reqFile::set_fileinqtext(const ::std::string& value) {
  
  fileinqtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.reqFile.fileInqText)
}
#if LANG_CXX11
inline void reqFile::set_fileinqtext(::std::string&& value) {
  
  fileinqtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.reqFile.fileInqText)
}
#endif
inline void reqFile::set_fileinqtext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fileinqtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.reqFile.fileInqText)
}
inline void reqFile::set_fileinqtext(const char* value, size_t size) {
  
  fileinqtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.reqFile.fileInqText)
}
inline ::std::string* reqFile::mutable_fileinqtext() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.reqFile.fileInqText)
  return fileinqtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* reqFile::release_fileinqtext() {
  // @@protoc_insertion_point(field_release:DDRCommProto.reqFile.fileInqText)
  
  return fileinqtext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void reqFile::set_allocated_fileinqtext(::std::string* fileinqtext) {
  if (fileinqtext != NULL) {
    
  } else {
    
  }
  fileinqtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fileinqtext);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.reqFile.fileInqText)
}

// -------------------------------------------------------------------

// respFile

// .DDRCommProto.respFile.eZipFormat zipFormat = 1;
inline void respFile::clear_zipformat() {
  zipformat_ = 0;
}
inline ::DDRCommProto::respFile_eZipFormat respFile::zipformat() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFile.zipFormat)
  return static_cast< ::DDRCommProto::respFile_eZipFormat >(zipformat_);
}
inline void respFile::set_zipformat(::DDRCommProto::respFile_eZipFormat value) {
  
  zipformat_ = value;
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.zipFormat)
}

// string fileResp = 2;
inline void respFile::clear_fileresp() {
  fileresp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& respFile::fileresp() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.respFile.fileResp)
  return fileresp_.GetNoArena();
}
inline void respFile::set_fileresp(const ::std::string& value) {
  
  fileresp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.respFile.fileResp)
}
#if LANG_CXX11
inline void respFile::set_fileresp(::std::string&& value) {
  
  fileresp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.respFile.fileResp)
}
#endif
inline void respFile::set_fileresp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fileresp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.respFile.fileResp)
}
inline void respFile::set_fileresp(const char* value, size_t size) {
  
  fileresp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.respFile.fileResp)
}
inline ::std::string* respFile::mutable_fileresp() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.respFile.fileResp)
  return fileresp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* respFile::release_fileresp() {
  // @@protoc_insertion_point(field_release:DDRCommProto.respFile.fileResp)
  
  return fileresp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void respFile::set_allocated_fileresp(::std::string* fileresp) {
  if (fileresp != NULL) {
    
  } else {
    
  }
  fileresp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fileresp);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.respFile.fileResp)
}

// -------------------------------------------------------------------

// notifyStatus

// string statusMsg = 1;
inline void notifyStatus::clear_statusmsg() {
  statusmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyStatus::statusmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyStatus.statusMsg)
  return statusmsg_.GetNoArena();
}
inline void notifyStatus::set_statusmsg(const ::std::string& value) {
  
  statusmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyStatus.statusMsg)
}
#if LANG_CXX11
inline void notifyStatus::set_statusmsg(::std::string&& value) {
  
  statusmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyStatus.statusMsg)
}
#endif
inline void notifyStatus::set_statusmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  statusmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyStatus.statusMsg)
}
inline void notifyStatus::set_statusmsg(const char* value, size_t size) {
  
  statusmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyStatus.statusMsg)
}
inline ::std::string* notifyStatus::mutable_statusmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyStatus.statusMsg)
  return statusmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyStatus::release_statusmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyStatus.statusMsg)
  
  return statusmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyStatus::set_allocated_statusmsg(::std::string* statusmsg) {
  if (statusmsg != NULL) {
    
  } else {
    
  }
  statusmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), statusmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyStatus.statusMsg)
}

// -------------------------------------------------------------------

// notifyAlarm

// string alarmMsg = 1;
inline void notifyAlarm::clear_alarmmsg() {
  alarmmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyAlarm::alarmmsg() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyAlarm.alarmMsg)
  return alarmmsg_.GetNoArena();
}
inline void notifyAlarm::set_alarmmsg(const ::std::string& value) {
  
  alarmmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyAlarm.alarmMsg)
}
#if LANG_CXX11
inline void notifyAlarm::set_alarmmsg(::std::string&& value) {
  
  alarmmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyAlarm.alarmMsg)
}
#endif
inline void notifyAlarm::set_alarmmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  alarmmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyAlarm.alarmMsg)
}
inline void notifyAlarm::set_alarmmsg(const char* value, size_t size) {
  
  alarmmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyAlarm.alarmMsg)
}
inline ::std::string* notifyAlarm::mutable_alarmmsg() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyAlarm.alarmMsg)
  return alarmmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyAlarm::release_alarmmsg() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyAlarm.alarmMsg)
  
  return alarmmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyAlarm::set_allocated_alarmmsg(::std::string* alarmmsg) {
  if (alarmmsg != NULL) {
    
  } else {
    
  }
  alarmmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alarmmsg);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyAlarm.alarmMsg)
}

// -------------------------------------------------------------------

// notifyTextChat

// string chatText = 1;
inline void notifyTextChat::clear_chattext() {
  chattext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& notifyTextChat::chattext() const {
  // @@protoc_insertion_point(field_get:DDRCommProto.notifyTextChat.chatText)
  return chattext_.GetNoArena();
}
inline void notifyTextChat::set_chattext(const ::std::string& value) {
  
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DDRCommProto.notifyTextChat.chatText)
}
#if LANG_CXX11
inline void notifyTextChat::set_chattext(::std::string&& value) {
  
  chattext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DDRCommProto.notifyTextChat.chatText)
}
#endif
inline void notifyTextChat::set_chattext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DDRCommProto.notifyTextChat.chatText)
}
inline void notifyTextChat::set_chattext(const char* value, size_t size) {
  
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DDRCommProto.notifyTextChat.chatText)
}
inline ::std::string* notifyTextChat::mutable_chattext() {
  
  // @@protoc_insertion_point(field_mutable:DDRCommProto.notifyTextChat.chatText)
  return chattext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* notifyTextChat::release_chattext() {
  // @@protoc_insertion_point(field_release:DDRCommProto.notifyTextChat.chatText)
  
  return chattext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void notifyTextChat::set_allocated_chattext(::std::string* chattext) {
  if (chattext != NULL) {
    
  } else {
    
  }
  chattext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chattext);
  // @@protoc_insertion_point(field_set_allocated:DDRCommProto.notifyTextChat.chatText)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DDRCommProto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DDRCommProto::CommonHeader_eFlowDir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::CommonHeader_eFlowDir>() {
  return ::DDRCommProto::CommonHeader_eFlowDir_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::CommonHeader_eDestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::CommonHeader_eDestType>() {
  return ::DDRCommProto::CommonHeader_eDestType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqLogin_eCltType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqLogin_eCltType>() {
  return ::DDRCommProto::reqLogin_eCltType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respLogin_eLoginRetCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respLogin_eLoginRetCode>() {
  return ::DDRCommProto::respLogin_eLoginRetCode_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respLogin_eCltType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respLogin_eCltType>() {
  return ::DDRCommProto::respLogin_eCltType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqTalk_eCallerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqTalk_eCallerType>() {
  return ::DDRCommProto::reqTalk_eCallerType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respTalk_eReceiverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respTalk_eReceiverType>() {
  return ::DDRCommProto::respTalk_eReceiverType_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::reqFile_eZipFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::reqFile_eZipFormat>() {
  return ::DDRCommProto::reqFile_eZipFormat_descriptor();
}
template <> struct is_proto_enum< ::DDRCommProto::respFile_eZipFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DDRCommProto::respFile_eZipFormat>() {
  return ::DDRCommProto::respFile_eZipFormat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_BaseCmd_2eproto
