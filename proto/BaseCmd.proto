syntax = "proto3";

package DDRCommProto;


// Abbreviation: LS - local server; C - client (local); LSM - local service module
//				 RS - remote server; M - monitor (remote); RR - remote robot (connect to RS)

// ------------------- Common message header ------------------- //

message CommonHeader
{
	// type of message body, e.g., "reqLogin"
	string bodyType = 1;
	
	// flow direction of the immediate transfer
	enum eFlowDir {
		UNKNOWN2RS = 0;
		RS2M = 1;
		M2RS = 2;
		RS2RR = 3;
		RR2RS = 4;
		UNKNOWN2LS = 5;
		LS2C = 6;
		C2LS = 7;
		LS2LSM = 8;
		LSM2LS = 9;
	}
	// repeated here is to indicate its validity (one and only one flowDirection)
	repeated eFlowDir flowDirection = 2;
		
	// If bOriginal==1, it is a message from its source (not forwarded).
	int32 bOriginal = 3;
	enum eSrcCondition {
		NoCond = 0;
		Op = 1;
	}
	// if (srcCond==Op) && (bOriginal==1) && (immediate source is not an Op. client or Op.
	// monitor), discard this whole frame. Otherwise okay to process.
	eSrcCondition srcCond = 4;	
	
	// NoForwarding: No direct forwarding. Need to decrypt and parse the message bodies. Typical
	//               use is in "notify*".
	// LSMAll:       For RS, forward the message body to RR; for LS, forward the message body
	//               to all connected LSMs. For an LSM, rspond if the message body asks for
	//               rsponse of its functionality (assuming no conflicts among different LSMs).
	//               Typical use is in "reqCmd".
	// CltMonAll:    For RS, forward the message body to all connected monitors; for LS, forward
	//               the message body to all connected clients, and RS (if connected). Typical
	//               use is in "reqStatus", "reqAlarm", and "reqTextChat".
	// ToOp:         For RS, forward the message body to the Op. monitor (if so); for LS, forward
	//               the message body to the Op. client if one connected client is Op., otherwise
	//               to the RS. Typical use is in "reqTalk" from robot_LSM.
	// RoutingBack:  In this case, field "prevRouteAddr" should NOT be empty. The last element in
	//               that field will be the target address (IP:port string) to forward messages,
	//               and that last element will be removed in the new CommonHeader sent along the 
	//               the message body. Typical use is in "rspCmd" and "rspTalk".
	enum eForwardingType {
		NoForwarding = 0; // simple notification, nothing to be forwarded
		LSMAll = 1; // message body will finally be forwarded to all LSMs
		CltMonAll = 2; // message body will finally be forwarded to all clients/monitors
		ToOp = 3; // message body will finally be forwarded to Op. (client/monitor)
		RoutingBack = 4; // this message will be forwarded along the previous routes
	}
	eForwardingType forwardType = 5;
	
	enum eSrcRecType {
		NoRec = 0; // routing info not recorded
		RecSrc = 1; // IMMEDIATE source will be appended to the previous routes in form like “192.168.1.1:234”
	}
	eSrcRecType recType = 6;
	repeated string prevRouteAddr = 7; // array of previous routes
}

// +++++++++++++++++++ Common message header +++++++++++++++++++ //

// ------------------- Common message bodies ------------------- //

// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message HeartBeat
{
	string whatever = 1;
}

// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message bcLSAddr
{
	enum eServiceType {
		LocalServer = 0;      //Local Server
		RemoteServer = 1;		//Remote Server
		RTSPStreamServer = 2; //RTSP Stream Server
		TalkBackServer = 3;		//Talk Back Server
	}
	
	message ServerInfo {
		string name = 1;
		eServiceType stype = 2;
		repeated string ips = 3;
		int32 port = 4; 
	}
	repeated ServerInfo LSInfos = 1;
}


enum eCltType {
	ePCClient = 0;
	eAndroidClient = 1;
	eLSMStreamRelay = 2;
	eLSMSlamNavigation = 3;
	eLSMFaceRecognition = 4;
	eLSMThermalImaging =5;
}
// flowDirection = UNKNOWN2RS or UNKNOWN2LS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message reqLogin
{

	eCltType type = 1;
	string username = 2; // nickname for clients/monitors, module name for LSM, ignored for RR
	string userpwd = 3;
}

// flowDirection = RS2M or RS2RR or LS2C or LS2LSM
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message rspLogin
{
	enum eLoginRetCode {
		success = 0;
		server_busy = 1;
		server_limit_reached = 2;
		incorrect_password = 3;
	}
	eLoginRetCode retcode = 1;
	eCltType yourRole = 2;
}

// flowDirection = RS2M or LS2C
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message notifyTerminalAccess
{
	int32 bRRConnected2RS = 1;
	int32 bOp = 2;
	int32 nMonitors = 3;
	int32 nClients = 4;
	repeated string nameLSMs = 5;
}

// flowDirection = RS2RR or RR2RS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message notifySerAccess
{
	// field 1~3 for RS2RR
	int32 nMonitors = 1;
	int32 mTopOpLv = 2; // op. level of the top monitor
	int32 mTopOpTime = 3; // connection time of the top monitor
	// field 4~7 for RR2RS
	int32 nClients = 4;
	int32 cTopOpLv = 5; // op. level of the top client
	int64 cTopOpTime = 6; // connection time of the top client
	repeated string namesLSM = 7;
}

// flowDirection = RS2M or RS2RR or LS2C or LS2LSM
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message notifyAVStream
{
	message fullChannelInfo {
		int32 devType = 1;
		int32 dataType = 2; // 0-N.A; 1-audio; 2-video; 3-audio+video
		string localResAccStr = 3; // UTF-8
		string channelDescription = 4; // UTF-8
		int32 bwReq = 5; // bandwidth requirement in kbps		
		int64 remoteIP = 6;
		int32 remotePort = 7;
		string remotePass = 8; // a special string that serves as the key to streaming servers
	}	
	fullChannelInfo reservedChannel = 1;
	repeated fullChannelInfo robotMonitorChannels = 2;
}

// if callerType == client,
//		flowDirection = C2LS or LS2LSM
//      eSrcCondition = Op; forwardType = LSMAll; eSrcRecType = RecSrc;
// if callerType == monitor,
//		flowDirection = M2RS or RS2RR or LS2LSM
//      eSrcCondition = Op; forwardType = LSMAll; eSrcRecType = RecSrc;
// if callerType == robot_LSM,
//		flowDirection = LSM2LS or LS2C or RR2RS or RS2M
//      eSrcCondition = NoCond; forwardType = ToOp; eSrcRecType = RecSrc;
message reqTalk
{
	enum eCallerType {
		client = 0;
		monitor = 1;
		robot_LSM = 2;
	}
	eCallerType callerType = 1;
	int32 talkID = 2; // a randomly generated ID for this session of talk
	int32 avType = 3; // 0-N.A; 1-audio; 2-video; 3-audio+video
	
	// when the call is only between two local devices (client->LSM or LSM->client)
	// these strings indicate caller's TCP server of talk. For client calling LSM,
	// this address is on the client side and the LSM will try to receive data there;
	// for LSM calling client, this address is on the LSM side and the client will try
	// to send data there.
	repeated string localTalkAddr = 4;
}

// if receiverType == client,
//		flowDirection = C2LS or LS2LSM
//      eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = RecSrc;
// if callerType == monitor,
//		flowDirection = M2RS or RS2RR or LS2LSM
//      eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = RecSrc;
// if receiverType == robot_LSM,
//		flowDirection = LSM2LS or LS2C or RR2RS or RS2M
//      eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = RecSrc;
// Note that this message body is sent along with field "prevRouteAddr" of the previously
// received message header (CommonHeader).
message rspTalk
{
	enum eReceiverType {
		client = 0;
		monitor = 1;
		robot_LSM = 2;
	}
	eReceiverType receiverType = 1;
	int32 talkID = 2; // a randomly generated ID for this session of talk
	int32 avType = 3; // 0-N.A; 1-audio; 2-video; 3-audio+video
}

// this is to maintain (dual) talk by sending heart beats
// flowDirection = any possibility
// eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = NoRec;
message reqTalkHB
{
	int32 callerTalkID = 1; // caller's talkID
	int32 receiverTalkID = 2; // receiver's talkID
}

// flowDirection = M2RS or RS2RR or C2LS or LS2LSM or LSM2LS
// eSrcCondition = Op; forwardType = LSMAll; eSrcRecType = RecSrc;
message reqCmd
{
	int64 cmdID = 1;
	string cmdMsg = 2;
}

// flowDirection = LSM2LS or RR2RS or RS2M or LS2C or LS2LSM
// eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = NoRec;
message rspCmd
{
	int64 cmdID = 1;
	string rspMsg = 2;
}

// flowDirection = LS2LSM
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message reqFile
{
	string tarLSMName = 1;
	enum eFileTypes {
		FileContents = 0;
		FileList = 1;
		FolderFlist = 2;
	}
	eFileTypes fileType = 2;
	repeated string fileNames = 3; // allow wildcards (*,?, etc)
}

// flowDirection = LSM2LS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message rspFile
{
	string tarLSMName = 1;
	enum eFileTypes {
		FileContents = 0;
		FileList = 1;
		FolderFlist = 2;
	}
	eFileTypes fileType = 2;
	repeated string fileNames = 3; // no wildcards
	repeated string fileContents = 4; // ignored if fileType!=FileContents
}

// flowDirection = M2RS or RS2RR or C2LS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message reqFileAddr
{
	string tarLSMName = 1;
	enum eFileTypes {
		FileContents = 0;
		FileList = 1;
		FolderFlist = 2;
	}
	eFileTypes fileType = 2;
	repeated string fileNames = 3;  // allow wildcards (*,?, etc)
}

// flowDirection = RR2RS or RS2M or LS2C
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message rspFileAddr
{
	string tarLSMName = 1;
	enum eFileTypes {
		FileContents = 0;
		FileList = 1;
		FolderFlist = 2;
	}
	eFileTypes fileType = 2;
	repeated string fileNames = 3; // no wildcards
	repeated string fileAddr = 4; // ignored if fileType!=FileContents
}

// flowDirection = LSM2LS or LS2C or RR2RS or RS2M
// eSrcCondition = NoCond; forwardType = CltMonAll; eSrcRecType = NoRec;
message reqStatus
{
	string statusMsg = 1;
}

// flowDirection = LSM2LS or LS2C or RR2RS or RS2M
// eSrcCondition = NoCond; forwardType = CltMonAll; eSrcRecType = NoRec;
message reqFaceAlarm
{
	string error = 1;
}

message reqHotAlarm
{
	string error = 1;
}
message reqObsAlarm
{
	
	string error = 1;
}

// flowDirection = C2LS or LS2C or RR2RS or M2RS or RS2M
// eSrcCondition = NoCond; forwardType = CltMonAll; eSrcRecType = NoRec;
message reqTextChat
{
	string chatText = 1;
}






enum ChannelNetworkType
{
		Local = 0;
		Remote = 1;
}
enum ChannelStreamType//bit mask
{
	Video = 0;
	Audio = 1;
	VideoAudio = 2;
}


//----------------------------------------------------------------------------------------------------------PC Android Client[[[[[[
message AVStreamSrcChannel
{
	string srcAddr = 1;
	repeated int32 srcPort = 2;//size = 0 means donot use it 
	ChannelStreamType streamType = 3;
	ChannelNetworkType networkType = 4;
}

message reqStreamAddr
{
	ChannelNetworkType networkType = 1;
}
message rspStreamAddr
{	
	repeated AVStreamSrcChannel channels = 1;
	string error = 2;
}
message notifyAlarm
{
	eCltType from = 1;
	string fromIP = 2;
	string error = 3;
	
}

//----------------------------------------------------------------------------------------------------------PC Android Client]]]]]]

//----------------------------------------------------------------------------------------------------------StreamRelayService[[[[[[
message AVChannelConfig
{
	

	string src = 1;
	string dst = 2;
	ChannelStreamType streamType = 3;
}

message reqStreamServiceInfo
{
	string name = 1;
	
}
message rspStreamServiceInfo
{
	int32 tcpPort = 1;
	repeated AVChannelConfig channels = 2;
	
}
message notifyStreamServiceInfoChanged
{
	repeated AVChannelConfig channels = 1;
}
message reqStreamRelayAlarm
{
	string error = 1;
	repeated eCltType to = 2;
}

//----------------------------------------------------------------------------------------------------------StreamRelayService]]]]]]



















// +++++++++++++++++++ Common message bodies +++++++++++++++++++ //