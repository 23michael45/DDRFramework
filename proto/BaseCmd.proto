syntax = "proto3";

package DDRCommProto;

//message head instruction
//req： Client request , Message to Server
//rsp:  Server response , Message to Client , response a request
//chk:  Server check Client , expect a answer
//ans:  Client answer a check , to Server
//notify: Server notify Client , donot need any answer or response
//HeartBeat: heartbeat , send every n sector
//bc: broadcast by server through udp

// Abbreviation: LS - local server; C - client (local); LSM - local service module
//				 RS - remote server; M - monitor (remote); RR - remote robot (connect to RS)

// ------------------- Common message header ------------------- //

message CommonHeader
{
	// type of message body, e.g., "reqLogin"
	string bodyType = 1;
	
	// flow direction of the immediate transfer
	enum eFlowDir {
		UNKNOWN2RS = 0;
		RS2M = 1;
		M2RS = 2;
		RS2RR = 3;
		RR2RS = 4;
		UNKNOWN2LS = 5;
		LS2C = 6;
		C2LS = 7;
		LS2LSM = 8;
		LSM2LS = 9;
	}
	// repeated here is to indicate its validity (one and only one flowDirection)
	repeated eFlowDir flowDirection = 2;
		
	// If bOriginal==1, it is a message from its source (not forwarded).
	int32 bOriginal = 3;
	enum eSrcCondition {
		NoCond = 0;
		Op = 1;
	}
	// if (srcCond==Op) && (bOriginal==1) && (immediate source is not an Op. client or Op.
	// monitor), discard this whole frame. Otherwise okay to process.
	eSrcCondition srcCond = 4;	
	
	// NoForwarding: No direct forwarding. Need to decrypt and parse the message bodies. Typical
	//               use is in "notify*".
	// LSMAll:       For RS, forward the message body to RR; for LS, forward the message body
	//               to all connected LSMs. For an LSM, rspond if the message body asks for
	//               rsponse of its functionality (assuming no conflicts among different LSMs).
	//               Typical use is in "reqCmd".
	// CltMonAll:    For RS, forward the message body to all connected monitors; for LS, forward
	//               the message body to all connected clients, and RS (if connected). Typical
	//               use is in "reqStatus", "reqAlarm", and "reqTextChat".
	// ToOp:         For RS, forward the message body to the Op. monitor (if so); for LS, forward
	//               the message body to the Op. client if one connected client is Op., otherwise
	//               to the RS. Typical use is in "reqTalk" from robot_LSM.
	// RoutingBack:  In this case, field "prevRouteAddr" should NOT be empty. The last element in
	//               that field will be the target address (IP:port string) to forward messages,
	//               and that last element will be removed in the new CommonHeader sent along the 
	//               the message body. Typical use is in "rspCmd" and "rspTalk".
	enum eForwardingType {
		NoForwarding = 0; // simple notification, nothing to be forwarded
		LSMAll = 1; // message body will finally be forwarded to all LSMs
		CltMonAll = 2; // message body will finally be forwarded to all clients/monitors
		ToOp = 3; // message body will finally be forwarded to Op. (client/monitor)
		RoutingBack = 4; // this message will be forwarded along the previous routes
	}
	eForwardingType forwardType = 5;
	
	enum eSrcRecType {
		NoRec = 0; // routing info not recorded
		RecSrc = 1; // IMMEDIATE source will be appended to the previous routes in form like “192.168.1.1:234”
	}
	eSrcRecType recType = 6;
	repeated string prevRouteAddr = 7; // array of previous routes
}

// +++++++++++++++++++ Common message header +++++++++++++++++++ //

// ------------------- Common message bodies ------------------- //

// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message HeartBeat
{
	string whatever = 1;
}

// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message bcLSAddr
{
	enum eServiceType {
		LocalServer = 0;      //Local Server
		RemoteServer = 1;		//Remote Server
		RTSPStreamServer = 2; //RTSP Stream Server
		TalkBackServer = 3;		//Talk Back Server
	}
	
	message ServerInfo {
		string name = 1;
		eServiceType stype = 2;
		repeated string ips = 3;
		int32 port = 4; 
		string robotid = 5;
	}
	repeated ServerInfo LSInfos = 1;
}


enum eCltType {
	ePCClient = 0;
	eAndroidClient = 1;
	eLSMStreamRelay = 2;
	eLSMSlamNavigation = 3;
	eLSMFaceRecognition = 4;
	eLSMThermalImaging =5;
}
// flowDirection = UNKNOWN2RS or UNKNOWN2LS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message reqLogin
{

	eCltType type = 1;
	string username = 2; // nickname for clients/monitors, module name for LSM, ignored for RR
	string userpwd = 3;
}

// flowDirection = RS2M or RS2RR or LS2C or LS2LSM
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message rspLogin
{
	enum eLoginRetCode {
		success = 0;
		server_busy = 1;
		server_limit_reached = 2;
		incorrect_password = 3;
	}
	eLoginRetCode retcode = 1;
	eCltType yourRole = 2;
}

// flowDirection = RS2M or LS2C
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message notifyTerminalAccess
{
	int32 bRRConnected2RS = 1;
	int32 bOp = 2;
	int32 nMonitors = 3;
	int32 nClients = 4;
	repeated string nameLSMs = 5;
}

// flowDirection = RS2RR or RR2RS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message notifySerAccess
{
	// field 1~3 for RS2RR
	int32 nMonitors = 1;
	int32 mTopOpLv = 2; // op. level of the top monitor
	int32 mTopOpTime = 3; // connection time of the top monitor
	// field 4~7 for RR2RS
	int32 nClients = 4;
	int32 cTopOpLv = 5; // op. level of the top client
	int64 cTopOpTime = 6; // connection time of the top client
	repeated string namesLSM = 7;
}

// flowDirection = RS2M or RS2RR or LS2C or LS2LSM
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message notifyAVStream
{
	message fullChannelInfo {
		int32 devType = 1;
		int32 dataType = 2; // 0-N.A; 1-audio; 2-video; 3-audio+video
		string localResAccStr = 3; // UTF-8
		string channelDescription = 4; // UTF-8
		int32 bwReq = 5; // bandwidth requirement in kbps		
		int64 remoteIP = 6;
		int32 remotePort = 7;
		string remotePass = 8; // a special string that serves as the key to streaming servers
	}	
	fullChannelInfo reservedChannel = 1;
	repeated fullChannelInfo robotMonitorChannels = 2;
}

// if callerType == client,
//		flowDirection = C2LS or LS2LSM
//      eSrcCondition = Op; forwardType = LSMAll; eSrcRecType = RecSrc;
// if callerType == monitor,
//		flowDirection = M2RS or RS2RR or LS2LSM
//      eSrcCondition = Op; forwardType = LSMAll; eSrcRecType = RecSrc;
// if callerType == robot_LSM,
//		flowDirection = LSM2LS or LS2C or RR2RS or RS2M
//      eSrcCondition = NoCond; forwardType = ToOp; eSrcRecType = RecSrc;
message reqTalk
{
	enum eCallerType {
		client = 0;
		monitor = 1;
		robot_LSM = 2;
	}
	eCallerType callerType = 1;
	int32 talkID = 2; // a randomly generated ID for this session of talk
	int32 avType = 3; // 0-N.A; 1-audio; 2-video; 3-audio+video
	
	// when the call is only between two local devices (client->LSM or LSM->client)
	// these strings indicate caller's TCP server of talk. For client calling LSM,
	// this address is on the client side and the LSM will try to receive data there;
	// for LSM calling client, this address is on the LSM side and the client will try
	// to send data there.
	repeated string localTalkAddr = 4;
}

// if receiverType == client,
//		flowDirection = C2LS or LS2LSM
//      eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = RecSrc;
// if callerType == monitor,
//		flowDirection = M2RS or RS2RR or LS2LSM
//      eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = RecSrc;
// if receiverType == robot_LSM,
//		flowDirection = LSM2LS or LS2C or RR2RS or RS2M
//      eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = RecSrc;
// Note that this message body is sent along with field "prevRouteAddr" of the previously
// received message header (CommonHeader).
message rspTalk
{
	enum eReceiverType {
		client = 0;
		monitor = 1;
		robot_LSM = 2;
	}
	eReceiverType receiverType = 1;
	int32 talkID = 2; // a randomly generated ID for this session of talk
	int32 avType = 3; // 0-N.A; 1-audio; 2-video; 3-audio+video
}

// this is to maintain (dual) talk by sending heart beats
// flowDirection = any possibility
// eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = NoRec;
message reqTalkHB
{
	int32 callerTalkID = 1; // caller's talkID
	int32 receiverTalkID = 2; // receiver's talkID
}

// flowDirection = M2RS or RS2RR or C2LS or LS2LSM or LSM2LS
// eSrcCondition = Op; forwardType = LSMAll; eSrcRecType = RecSrc;
message reqCmd
{
	int64 cmdID = 1;
	string cmdMsg = 2;
}

// flowDirection = LSM2LS or RR2RS or RS2M or LS2C or LS2LSM
// eSrcCondition = NoCond; forwardType = RoutingBack; eSrcRecType = NoRec;
message rspCmd
{
	int64 cmdID = 1;
	string rspMsg = 2;
}
//-----------------------------------ClientCmd[[[[[
enum eCmdRspType{
	eSuccess = 0;				// Cmd success
	eCmdFailed = 1;				// Cmd failed
	eNoAuthority = 2;			// user no authority
	eRobotNoLogin = 3;			// robot no online
	eLSMNoLogin = 4;			// lsm no online
}
// Cmd move 
message reqCmdMove{ 
	float line_speed = 1;		// Cmd Robot forward or back off
	float angulau_speed =2;		// Cmd Robot turn left or right
}
message rspCmdMove{
	eCmdRspType type =1;
}
// Cmd change speed
message reqCmdChangeSpeed{
	char add_speed = 1;		// Cmd change robot speed of autorun | 0x01 = speed up | 0xff = speed down
}
message rspCmdChangeSpeed{
	eCmdRspType type = 1;
}
// Cmd pause or resume
message reqCmdPauseResume {
	string error = 1; 			// Cmd robot Pause or Resume of autorun
}
message rspCmdPauseResume{
	eCmdRspType type = 1;
}
// Cmd IPC Shutdown or ReStart or Volume
enum eCmdIPCMode{
	eShutDown = 0;		//	close IPC
	eReStart = 1;		//	restart IPC
	eVolume = 3;		//	change IPC volume
} 
message reqCmdIPC{
	eCmdIPCMode mode = 1;	// Cmd IPC to Shutdown or ReStart or Volume
	int32 values = 2;		//	volume change values
}
message rspCmdIPC{
	eCmdIPCMode mode = 1;	// IPC implement Shutdown or ReStart or Volume
	eCmdRspType type = 1;
	int32 values = 3;		// Current volume
}
// Cmd Robot start or stop play audio
message reqCmdAudio{
	enum eAudioMode{
		eTTS = 0;				// TTS : "helloword"
		eFile = 1;				// File : "c:\aaa\bbb\ccc.wav" | "aaa.wav"
	}
	enum eAudioOperational{
		eStart = 0;
		eStop = 1;
	}
	eAudioOperational = 1;		// Cmd start or stop
	eAudioMode type = 2;		// audio play mode
	string Audiostr = 3;		// TTS or File content 
	int32 level = 4;			// play audio level
}
message rspCmdVoiceAlarm{
	eCmdRspType type = 1;
}
// Cmd update config
message reqCmdUpdateConfig{
	string data = 1;			// config.dat change cmd
	string dataname = 2;		// change dataname
}
message rspCmdUpdateConfig{
	eCmdRspType type = 1;
	string dataname = 2;		// change dataname
}
// Cmd get configdata
message reqCmdGetConfigdata{
	string error = 1;
}
message rspCmdGetConfigdata{
	eCmdRspType type = 1;
	repeated char configdata = 2;	// config.dat
}
// Cmd set work path
message reqCmdSetWorkPath{
	string route_name = 1;		// route_name : OneRoute_XXXXXX
	string path_name = 2;		// path_name : path_auto.txt
	float speed = 3;			// speed : 0~0.7
}
message rspCmdSetWorkPath {
	eCmdRspType type = 1;
}
// Cmd add face
enum ePersonType{
	eWhiteList = 0;
	eBlackList =1;
	eRedList = 2;
}
message reqCmdAddFace {
	string name = 1;			
	PersonType type = 2;		
	repeated char picdata = 3;	// face picture data
}
message rspCmdAddFace{
	eCmdRspType type = 1;
}
// Cmd Get alarm params
enum eAlarmType{
	eFaceAlarmParams = 0;
	eThermalAlarmParams = 1;
}
message reqCmdGetAlarmParams{
	eAlarmType alarmtype = 1;		// Get Face params or Thermal params
}
message rspCmdThermalGetParams{
	eCmdRspType type = 1;
	eAlarmType alarmtype = 2;		// rsp Face params or Thermal params
	float alarmtemp = 2;
}
// Cmd operation face database
message reqCmdFaceDataBaseOrder{
	string Order = 1;				// Order ： "SELECT COUNT(*) FROM DDRPersonLib;" | "SELECT * FROM DDRPersonLib WHERE PersonIndex = 3;"
}
message FaceDataBaseData{
	int32 id = 1;				
	string name = 2;
	ePersonType type = 3;
	string label = 4;
}
message rspCmdFaceDataBaseOrder {
	enum eRspDataBaseType{
		eError = 0;
		eQueryCount = 1;
		eDeleteSuccess = 2;
		eDetailedData = 3;
	}
	eCmdRspType type = 1;
	repeated FaceDataBaseData data = 2;
}
// Cmd set face confidence or alarm params
enum eFaceParams{
	eConfidence = 0;				// over Confidence output to recognition	advise : > 0.9
	eAlarmTemp = 1;					// over alarmtemp output to display			advise : 60~80 | 67
}
message reqCmdSetFaceParams{
	eFaceParams param = 1;
	float param_num = 2;
}
message rspCmdSetFaceParams{
	eCmdRspType type = 1;
	eFaceParams param = 2;
}
// Cmd set autochat type
message reqCmdAutoChat{
	enum eAutoChatType{
		eStartOnline = 0;			
		eStartOffline = 1;
		eStop = 2;
	}
	eAutoChatType type = 1;
	int32 comnum = 2;			// MIC number
}
message rspCmdAutoChat{
	eCmdRspType type = 1;
}
// Cmd create or query ot
message reqCmdGeneralOctree{
	enum eOctreeType{
		eCreate = 0;
		eQuery = 1;
	}
	string route_name = 1;			// route_name : OneRoute_XXXXXX
	eOctreeType type = 2;			// create or query ot
}
message rspCmdGeneralOctree {
	enum eRspOctreeType{
		eFileNotExists = 0;
		eFileExists = 1;
		eInCreate = 2;
	}
	eCmdRspType type = 1;
	eRspOctreeType otype = 2;
}
// Cmd change robot runmode
enum eCmdActionMode{
	eAutoDynamic = 0;
	eAutoStatic = 1;
	eBlindWaldDynamic = 2;
	eBlindWaldStatic = 3;
	eRec = 4;
	eReCharging = 5;
}
// Cmd start to autorun or rec
message reqCmdStartActionMode{
	eCmdActionMode mode = 1;
	string route_name = 2;
}
message rspCmdStartActionMode{
	eCmdActionMode mode = 1;
	eCmdRspType type = 2;
}
// Cmd stop autorun or out rec
message reqCmdEndActionMode{
	string error = 1;
}
message rspCmdEndActionMode{
	eCmdActionMode = 1;
	eCmdRspType = 2;
	string route_name = 3;
}

//-----------------------------------ClientCmd]]]]]

//-----------------------------------ClientStatus[[[[[
// BaseStatus
message notifyBaseStatus{
	int32 mode = 1;
	int32 sonmode =2;
	float batt = 3;
	float temp = 4;
	float hum = 5;
	float pm25 = 6;
	int32 stopstat = 7;
	int64 funcstat = 8;
	int32 voiceloop = 9;
	string currroute = 10;
	string currpath = 11;
	float currspeed = 12;
	string currwalkstyle = 13;
	float posx = 14;
	float posy = 15;
	float posdirection = 16;
	float poslinespeed = 17;
	float posangulauspeed = 18;
	double longitude = 19;
	double latitude = 20;
	int64 timestamp = 21;
	int32 thermalmaxx = 22;
	int32 thermalmaxy = 23;
	float thermalmaxvalue = 24;
}
//ObsStatus
message OAInfo{
	float startangle = 1;
	float endangle = 2;
	float dist = 3;
}
message notifyObsData{
	int32 greedred = 1;
	float maxdist = 2;
	repeated OAInfo oastat = 3;
}
//-----------------------------------ClientStatus]]]]]

//-----------------------------------ClientAlarm[[[[[
// Alarm Thermal or ObsStatus
message notifyAlarmInfo{
	enum eAlarmType{
		eThermalAlarm = 0;
		eObsStatusAlarm = 1;
	}
	eAlarmType type = 1;
	string alarmcontent= 2;
}
// Alarm face
message notifyAlarmNewFace{
	ePersonType type = 1;
	string name = 2;
	float socre = 3;
	int64 prevtime = 4;
	repeated char facedecode = 5;
}
// Alarm Fire
message AlarmFirePos{
	int32 posx = 1;
	int32 posy = 2;
	int32 poswidth = 3;
	int32 posheight = 4;
	int32 maxtem = 5;
	int32 avgtem = 6;
	int32 alarmpointcount = 7;
}
message notifyAlarmFire {
	repeated AlarmFirePos pos = 1;
}

//-----------------------------------ClientAlarm]]]]]
enum eFileTypes {
	FileContents = 0;
	FileHttpAddress = 1;
}
// flowDirection = LS2LSM
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message chkFileStatus
{
	eFileTypes fileType = 1;
	repeated string fileNames = 2; // allow wildcards (*,?, etc)
}

// flowDirection = LSM2LS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message ansFileStatus
{
	eFileTypes fileType = 1;
	repeated string fileAddrList = 2; // no wildcards
}



// flowDirection = LSM2LS or LS2C or RR2RS or RS2M
// eSrcCondition = NoCond; forwardType = CltMonAll; eSrcRecType = NoRec;
message reqStatus
{
	string statusMsg = 1;
}

// flowDirection = LSM2LS or LS2C or RR2RS or RS2M
// eSrcCondition = NoCond; forwardType = CltMonAll; eSrcRecType = NoRec;
message reqFaceAlarm
{
	string error = 1;
}

message reqHotAlarm
{
	string error = 1;
}
message reqObsAlarm
{
	
	string error = 1;
}

// flowDirection = C2LS or LS2C or RR2RS or M2RS or RS2M
// eSrcCondition = NoCond; forwardType = CltMonAll; eSrcRecType = NoRec;
message reqTextChat
{
	string chatText = 1;
}






enum ChannelNetworkType
{
		Local = 0;
		Remote = 1;
}
enum ChannelStreamType//bit mask
{
	Video = 0;
	Audio = 1;
	VideoAudio = 2;
}


//----------------------------------------------------------------------------------------------------------PC Android Client[[[[[[
message AVStreamSrcChannel
{
	string srcAddr = 1;
	repeated int32 srcPort = 2;//size = 0 means donot use it 
	ChannelStreamType streamType = 3;
	ChannelNetworkType networkType = 4;
	int32 rate = 5;
}

message reqStreamAddr
{
	ChannelNetworkType networkType = 1;
}
message rspStreamAddr
{	
	repeated AVStreamSrcChannel channels = 1;
	string error = 3;
}
message notifyAlarm
{
	eCltType from = 1;
	string fromIP = 2;
	string error = 3;
	
}
// flowDirection = M2RS or RS2RR or C2LS
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message reqFileAddress
{
	eCltType tarServiceType = 1;
	eFileTypes fileType = 2;
	repeated string fileNames = 3;  // allow wildcards (*,?, etc)
}

// flowDirection = RR2RS or RS2M or LS2C
// eSrcCondition = NoCond; forwardType = NoForwarding; eSrcRecType = NoRec;
message rspFileAddress
{
	eCltType tarServiceType = 1;
	eFileTypes fileType = 2;
	repeated string fileAddrList = 3; // ignored if fileType!=FileContents
	string error = 4;
}
//----------------------------------------------------------------------------------------------------------PC Android Client]]]]]]

//----------------------------------------------------------------------------------------------------------StreamRelayService[[[[[[
message AVChannelConfig
{
	

	string src = 1;
	string dst = 2;
	ChannelStreamType streamType = 3;
	ChannelNetworkType networkType = 4;
	int32 rate = 5;
}

message reqStreamServiceInfo
{
	string name = 1;
	
}
message rspStreamServiceInfo
{
	int32 tcpPort = 1;
	repeated AVChannelConfig channels = 2;
	
}
message notifyStreamServiceInfoChanged
{
	repeated AVChannelConfig channels = 1;
}
message reqStreamRelayAlarm
{
	string error = 1;
	repeated eCltType to = 2;
}

//----------------------------------------------------------------------------------------------------------StreamRelayService]]]]]]



















// +++++++++++++++++++ Common message bodies +++++++++++++++++++ //